<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Golocron â€“ Software Development With Go</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Design software for change">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="u00-intro.html">Golocron</a></li><li class="chapter-item expanded affix "><li class="part-title">The Style Guide</li><li class="chapter-item expanded "><a href="u01-00-introduction.html"><strong aria-hidden="true">1.</strong> Project Layout</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u01-01-good-and-bad-layout.html"><strong aria-hidden="true">1.1.</strong> Good and Bad Layout</a></li><li class="chapter-item expanded "><a href="u01-02-types-of-layouts.html"><strong aria-hidden="true">1.2.</strong> Types of Layouts</a></li><li class="chapter-item expanded "><a href="u01-03-common.html"><strong aria-hidden="true">1.3.</strong> Common</a></li><li class="chapter-item expanded "><a href="u01-04-library.html"><strong aria-hidden="true">1.4.</strong> Library</a></li><li class="chapter-item expanded "><a href="u01-05-single-application.html"><strong aria-hidden="true">1.5.</strong> Single Application</a></li><li class="chapter-item expanded "><a href="u01-06-monorepo.html"><strong aria-hidden="true">1.6.</strong> Monolithic Repository</a></li><li class="chapter-item expanded "><a href="u01-07-monorepo-extra.html"><strong aria-hidden="true">1.7.</strong> Monorepo: Additional Chapters</a></li><li class="chapter-item expanded "><a href="u01-08-versioning-and-go.html"><strong aria-hidden="true">1.8.</strong> Versioning and Go</a></li><li class="chapter-item expanded "><a href="u01-09-notes-on-release-notes.html"><strong aria-hidden="true">1.9.</strong> Notes on Release Notes</a></li><li class="chapter-item expanded "><a href="u01-10-summary.html"><strong aria-hidden="true">1.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="u02-00-introduction.html"><strong aria-hidden="true">2.</strong> Package Layout</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u02-01-what-is-a-package.html"><strong aria-hidden="true">2.1.</strong> What is a Package</a></li><li class="chapter-item expanded "><a href="u02-02-when-to-create-a-package.html"><strong aria-hidden="true">2.2.</strong> When to Create a Package</a></li><li class="chapter-item expanded "><a href="u02-03-keep-public-api-narrow.html"><strong aria-hidden="true">2.3.</strong> Keep Public API as Narrow as Possible</a></li><li class="chapter-item expanded "><a href="u02-04-the-main-package.html"><strong aria-hidden="true">2.4.</strong> The Main Package</a></li><li class="chapter-item expanded "><a href="u02-05-package-provides-something.html"><strong aria-hidden="true">2.5.</strong> Package Provides Something</a></li><li class="chapter-item expanded "><a href="u02-06-naming-a-package.html"><strong aria-hidden="true">2.6.</strong> Naming a Package</a></li><li class="chapter-item expanded "><a href="u02-07-structure.html"><strong aria-hidden="true">2.7.</strong> Structure</a></li><li class="chapter-item expanded "><a href="u02-08-files-in-a-package.html"><strong aria-hidden="true">2.8.</strong> Files in a Package</a></li><li class="chapter-item expanded "><a href="u02-09-cross-platform-code.html"><strong aria-hidden="true">2.9.</strong> Cross-Platform Code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u02-10-basic-principles-cp.html"><strong aria-hidden="true">2.9.1.</strong> Basic Principles of Writing Cross-Platform Code</a></li><li class="chapter-item expanded "><a href="u02-11-cp-options-in-go.html"><strong aria-hidden="true">2.9.2.</strong> Cross-Platform Options in Go</a></li></ol></li><li class="chapter-item expanded "><a href="u02-12-cp-package-and-file-organisation.html"><strong aria-hidden="true">2.10.</strong> Package and File Organisation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u02-13-cp-keep-code-at-minimum.html"><strong aria-hidden="true">2.10.1.</strong> Keep Platform-Dependent Code at Minimum</a></li><li class="chapter-item expanded "><a href="u02-14-cp-simple-branching.html"><strong aria-hidden="true">2.10.2.</strong> Use Simple Branching in Trivial Cases</a></li><li class="chapter-item expanded "><a href="u02-15-cp-no-platform-code-in-main.html"><strong aria-hidden="true">2.10.3.</strong> No Platform-Specific Code in Main</a></li><li class="chapter-item expanded "><a href="u02-16-cp-file-suffix-by-default.html"><strong aria-hidden="true">2.10.4.</strong> Use File Suffix by Default</a></li><li class="chapter-item expanded "><a href="u02-17-cp-build-tags-in-mixed-cases.html"><strong aria-hidden="true">2.10.5.</strong> Use Build Tags in Mixed Cases</a></li><li class="chapter-item expanded "><a href="u02-18-cp-advanced-example.html"><strong aria-hidden="true">2.10.6.</strong> An Advanced Example</a></li><li class="chapter-item expanded "><a href="u02-19-cp-platform-independent-tests.html"><strong aria-hidden="true">2.10.7.</strong> Strive for Platform-Independent Tests</a></li><li class="chapter-item expanded "><a href="u02-20-cp-cross-platform-tests.html"><strong aria-hidden="true">2.10.8.</strong> Provide Cross-Platform Tests Only When You Must</a></li></ol></li><li class="chapter-item expanded "><a href="u02-21-summary.html"><strong aria-hidden="true">2.11.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> File Layout</div></li><li class="chapter-item expanded affix "><li class="part-title">Foundation</li><li class="chapter-item expanded affix "><li class="part-title">Application Design</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Golocron â€“ Software Development With Go</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="golocron--software-development-with-go"><a class="header" href="#golocron--software-development-with-go">Golocron â€“ Software Development With Go</a></h1>
<p><em>by Pavel Burmistrov</em></p>
<p>TBD.</p>
<h1 id="project-layout"><a class="header" href="#project-layout">Project Layout</a></h1>
<p>Starting from a clean slate is always a pleasure when it comes to a new software project. There is no legacy <em>yet</em>, no technical debt and any other sources of anxiety. The pleasant experience can be maintained at a high level throughout the project's lifecycle. One of the key contributors to the experience of developing and maintaining a project is its layout, the file and folder structure and organisation. In the world of Go it's extremely important because a structure can be both helping and limiting, depending on how it's implemented.</p>
<p>This unit focuses on the project layout design. A layout design is how the folders and files are organised in a codebase, and thus in the repository containing the codebase. A layout sets the stage for all further design and architecture decisions for a project, such as package layout, logical and functional grouping. It also affects maintenance routines like producing build artefacts, CI and CD, rolling out and shipping to the user.</p>
<p>Depending on whether a layout is good or not, it may either significantly help and simplify everyday tasks, or it can make them quite complicated and poor. A good project layout helps you leverage and benefit from technology, whereas with a bad design any change to the structure is more of a fight with technology.</p>
<p>The importance of creating and following a good layout is clear. You create a project once, and this operation is technically quick and easy. But you have to work with the project until it's sunsetted, and this may and should last for years. The ease of creating a new folder hides the importance of putting a thought into how to set a project in a way that's both helping, convenient and makes sense. It's better to take some time to think about how this is going to look like in a week, a month, half a year, and two years from now. If this is done <em>before</em> anything is created, then working on the project will be much easier.</p>
<p>The rest of the unit covers the following:</p>
<ul>
<li>Good vs. Bad project layout</li>
<li>Layout for a library</li>
<li>Single application layout</li>
<li>Layout for a monolithic, multi-service repository</li>
<li>Versioning and Go</li>
<li>Creating a Changelog.</li>
</ul>
<p>Now, let's figure out what makes a project layout good and bad.</p>
<p><em>Disclaimer:</em> Terms &quot;good&quot; and &quot;bad&quot; are used as simple words to describe something that feels right, positive, helps and supports, as opposed to something that is less right, inconvenient, slows down and distracts. They're used not as judgements or labels, but as synonyms for respective broader terms.</p>
<h2 id="good-and-bad-layout"><a class="header" href="#good-and-bad-layout">Good and Bad Layout</a></h2>
<p>You can't know if something is good until you learn what a similar bad thing looks like. A bad thing might be perceived as good <em>until</em> you experience a truly good thing. Take, for instance, coffee. For someone who has never had it, almost any coffee can be considered as coffee, and it may even be unquestioned. But when after trying various kinds you take a sip of Supreme coffee made well, you no longer think that coffee from a Nespresso machine is tasty.</p>
<p>So, what makes a project layout bad? Can it even be bad? Why should we bother about it?</p>
<h3 id="bad-layout"><a class="header" href="#bad-layout">Bad Layout</a></h3>
<p>Have you ever been supporting a project with so long list of files scattered in the root directory, so it takes you several scrolls to get to the README file on the project's repository homepage on GitHub?</p>
<p>Have you ever been maintaining a project where half of the application is contained in the <code>main</code> package, and the entirety of the <code>main</code> package resides at the root level of the repository?</p>
<p>How often do you find unnecessary artefacts in a repository after building an application or running tests?</p>
<p>How often did you need to replace or move parts of a project and then fix the imports to fix an import cycle, or when the structure no longer makes sense?</p>
<p>How often do you find a folder that exists only to contain another folder?</p>
<p>Positive answers to any of these and other similar questions are signs of that you've encountered a bad project layout. When working with such a project, even as simple operation as building a binary can turn into trouble since you don't know whether the resulting binary will be accidentally included with the next commit or not.</p>
<p>So what are the characteristics of a suboptimal layout anyway? It can be nearly anything that leads to any of the following symptoms:</p>
<ul>
<li>a long list of files scattered at the root or any other level of a project</li>
<li>a long list directories scattered at the root or any other level of a project</li>
<li>files of different purposes are mixed at the root or any other level
<ul>
<li>code and configuration files (the app's configuration files)</li>
<li>code and CI scripts</li>
<li>code and tool's configurations</li>
<li>images or any other content</li>
</ul>
</li>
<li>there is no definite place for outputting build artefacts</li>
<li><code>.gitignore</code> does not exclude anything that should not be committed</li>
<li>the structure does not support or reflect architecture of a project
<ul>
<li>having both <code>app</code> and <code>server</code> directories at the same level - does this project provide an app? Or a server? Or it's a poor project layout design?</li>
</ul>
</li>
<li>the project structure leads to leakage of implementation details to the public API surface level
<ul>
<li>users can use parts of the implementation that are supposed to be internal</li>
<li>thus maintenance of the project is now complicated and slowed down since the public API is much broader than it should be</li>
</ul>
</li>
<li>the project structure is unnecessarily complicated and contains a multi-level hierarchy that implements a taxonomy of packages</li>
</ul>
<p>A mixture of even two of the symptoms listed above can significantly complicate project development and maintenance in long-term. Even worse may things become if a project is large, and is being developed by more than one person. Suffering can be endless, if that's an open-source project, and it's a popular one.</p>
<p>So you really want to invest in a good project structure that will help and support you as the application evolves. What does make a good layout?</p>
<h3 id="good-layout"><a class="header" href="#good-layout">Good Layout</a></h3>
<p>Now as we have learned some of symptoms of a bad project layout, it's time to know how a good one looks and feels like?</p>
<p>Overall, a good structure should be unnoticeable in everyday work. It exists, but as if it were invisible. Once defined, described and set, it just guides you. It limits the number of mistakes, helps to onboard new developers, supports maintenance routines, and does help in many other different ways. Let's look at some of those.</p>
<p>A good design for layout suits well for a project:</p>
<ul>
<li>if a project is a library, the layout should reflect and <em>support</em> that</li>
<li>if a project is an application, then the layout should make development and maintenance easier</li>
<li>if a project uses the monolithic repository approach, it's clear where different services, libraries and other parts reside, and where to add new things.</li>
</ul>
<p>A good layout limits the chances of misplacing something:</p>
<ul>
<li>when files and directories are logically and functionally well organised, it's harder to misplace a new file</li>
<li>the structure helps in deciding whether a new file should be a part of the existing tree, or it deserves a new level.</li>
</ul>
<p>A good layout reduces the mental load required to work with a project day by day:</p>
<ul>
<li>it's clear where binaries should go</li>
<li>test coverage reports do not pollute commits</li>
<li>changing CI configuration is straightforward</li>
<li>files of different purposes are grouped in a way that makes logical and functional sense</li>
<li>it's hard to accidentally commit and push garbage files.</li>
</ul>
<p>A good layout simplifies navigation through a project:</p>
<ul>
<li>it's convenient and easy to navigate in an editor/IDE</li>
<li>the homepage looks nice and well organised</li>
<li>in a terminal window, it's easy to work with files using standard and simple console tools.</li>
</ul>
<p>A good layout helps you to maintain a project in a healthy state:</p>
<ul>
<li>implementation details are kept private, yet still available as exported within a project</li>
<li>the possibility of creating an import cycle is reduced by design</li>
<li>the structure and hierarchy represent the business logic and relations between different parts of a project.</li>
</ul>
<p>As you can see, a good layout is more than just the opposite of the symptoms of a bad one. A good layout is the foundation for a development process focused on producing great software. If you have it, then you've got more mental energy to focus on creative solutions for hard problems. If you don't, then part of the energy is wasted.</p>
<p>The layout of a project depends on many factors. The most important one is the kind of a project. The layout will be different for a library, a single application or service, and for a monolithic repository, while there are some commonalities that make better any kind of a project.</p>
<p>As we now have learned what makes a good layout, it's time to know how to structure projects of different types.</p>
<h2 id="types-of-layouts"><a class="header" href="#types-of-layouts">Types of Layouts</a></h2>
<p>The layout of a project depends on its type and purpose. The layout should suit the project well to help supporting it.</p>
<p>A good way to describe the importance of using a good layout is an analogy with clothes. We all have things that suit us well; in this case the clothes fit us naturally so we don't even notice its presence. When a thing doesn't suit well, we might not notice it too, but by the middle of a day we've experienced more stress; when the garment is taken off at the end of a day, it feels much better.</p>
<p>The same is true for a project. Its structure may be unnoticed because it's natural and convenient, whereas with other projects we sometimes can't recognise the source of anxiety. That anxiety, in fact, is a sum of many factors, and one of them might be an inconvenient structure of a project.</p>
<p>A project is created once, and is maintained until its end of life. This means that you really want to invest in a good structure so interactions with codebase are on the positive side, and facilitate productivity.</p>
<p>All projects are different, and there is no a hard set of rules one can follow without thinking about a particular use case. Yet we can confidently say that the majority of projects fall into one of the following three categories:</p>
<ul>
<li>libraries (packages, modules, frameworks, you name it, depending on the language and environment)</li>
<li>single services/applications (web services, CLI tools, GUI applications, etc)</li>
<li>all-in-one, or monolithic repositories (multiple services/applications and libraries).</li>
</ul>
<p>Some recommendations for different types of projects can be applied to all of them, and some are specific to a particular use case. For example, a library layout will be slightly different from a monolithic one.</p>
<p>By a project we mean a few related and similar things at the same time:</p>
<ul>
<li>the directory containing a project</li>
<li>the repository containing a project.</li>
</ul>
<p>In the modern world it's hard to imagine a project that is not published on some service for collaboration and synchronisation with other people. Even if a developer is working on a project alone, they still need to keep it in sync between different devices, and to make sure the code is not lost, if something happens to a computer.</p>
<p>Given that, the section assumes that some service is used to store code of a project. While there are many of them, for simplicity we assume it's GitHub.</p>
<p>The rest of the section focuses on describing guidelines; we start with the commonalities, and then consider aspects that are different. Because it's not hard rules, but rather suggestions, they're flexible, and will differ from project to project. There are also some exceptions, which is natural for any healthy-sense driven guidelines.</p>
<p><em>Disclaimer: Neither the author, nor this work are affiliated or benefit in any way from GitHub.</em></p>
<h2 id="common"><a class="header" href="#common">Common</a></h2>
<p>The ultimate goal of choosing an appropriate structure is to keep things nice and tidy which simplifies interactions with a codebase.</p>
<p>This includes:</p>
<ul>
<li>providing required files for a project</li>
<li>keeping the number of elements at the root level at a reasonable minimum</li>
<li>keeping the root (and any other) level clean and up to date</li>
<li>grouping non-code files by their purpose</li>
<li>refraining from creating unnecessary hierarchy of folders</li>
<li>having a single entry point for routine tasks</li>
<li>storing credentials somewhere else</li>
</ul>
<p>Let's talk about these in more detail.</p>
<h3 id="provide-files-required-for-a-project"><a class="header" href="#provide-files-required-for-a-project">Provide Files Required for a Project</a></h3>
<p>A project should contain files that describe its purpose, provide required information for the programming language and tools, and simplify its maintenance.</p>
<p>The following files are considered as required:</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>.gitignore</code></td><td>Provides rules that govern what's allowed to be committed. It helps keeping a repository free from garbage files.</td></tr>
<tr><td><code>go.mod</code>, <code>go.sum</code></td><td>Identify a Go module.</td></tr>
<tr><td><code>README.md</code></td><td>Provides the description and any useful information and documentation for a project.</td></tr>
<tr><td><code>LICENCE</code></td><td>Provides clarity on licensing for a project, and helps to avoid potential legal inconveniences.</td></tr>
<tr><td><code>Makefile</code></td><td>Provides a single entry point to all maintenance and routine tasks.</td></tr>
</tbody></table>
<p>The files listed above are a bare minimum, but required for a modern project. You do this once, but if it's done right, it helps you all the way further.</p>
<p>One thing to note is that even with no code at all, a repository is likely to contain about 6 files. This is why the next suggestion is important.</p>
<h3 id="keep-the-number-of-root-elements-at-minimum"><a class="header" href="#keep-the-number-of-root-elements-at-minimum">Keep the Number of Root Elements at Minimum</a></h3>
<p>The number of folders and files at the root level should be as minimal as it's possible and makes sense.</p>
<p>It's important because it allows you to stay focused on the task you intend to perform, and not be distracted by the need of wading through the files, scripts and configs.</p>
<p>To continue our clothes analogy, it's like with a wardrobe - in the morning it's better to take a nicely folded thing from a shelf. But this convenience costs you the responsibility. To get it, you have to fold clothes neatly after the use, and it's also important to carefully choose what to put into the wardrobe.</p>
<p>While this suggestion sounds vague, and it is, it can help you. Each time when you're about to add something at the root level, by default question the need. Usually, things are set at the root level at the beginning, and then added here rarely. When you justify the presence of something at the top level, think twice about a better place for a file/folder, or if it's needed at all.</p>
<h3 id="keep-any-level-clean-and-up-to-date"><a class="header" href="#keep-any-level-clean-and-up-to-date">Keep Any Level Clean and Up to Date</a></h3>
<p>Similarly to the root level, any level of the file tree in a project should be clean, with reasonably minimal number of files, free from garbage, and up to date.</p>
<p>This is important because:</p>
<ul>
<li>long file listings make navigation harder</li>
<li>poor organisation complicates maintenance of the mental model of a project in the developer's head</li>
<li>out-of-date files take up extra mental and physical space</li>
<li>accidentally committed files are misleading and confusing.</li>
</ul>
<p>When a new developer joins a project, how much time do they need to get a firm understanding of what's going on in a project? Does the structure help and guide your colleagues through the project? Does it reduce the effort to keep the important details in their heads? Or do they have to stop for a moment each time when stumbled upon a file which no one knows about, whether it's current or not?</p>
<p>A well-organised and maintained project itself helps people in their everyday jobs. Each time when adding a new file, think twice what <em>else</em> can be added in it further. When creating a directory, consider different scenarios a few months in advance. You don't want to end up with a mess one year after, and tidying up a larger and live project is much more of an effort than keeping it clean everyday. If the structure is supported on a daily basis, it will pay off in long-term.</p>
<p>While it's important to have a neat structure, sometimes it's easy to get too serious about a hierarchy. This is what the next suggestion is about.</p>
<h3 id="dont-create-artificial-hierarchy"><a class="header" href="#dont-create-artificial-hierarchy">Don't Create Artificial Hierarchy</a></h3>
<p>Keep the directory tree in a project as flat as it possible and makes sense. In other words, don't create artificial hierarchy just for the sake of hiding something.</p>
<p>This applies to both, files containing actual code (and we will discuss it in Unit 2), and other files like scripts, configurations, documentation, etc.</p>
<p>A general piece of advice here is that any directory that contains only a single or multiple directories, or a single file, should be questioned for its purpose and existence. Does it belong in here, or somewhere else? Sometimes it might not be clear at the beginning, and this is why it's important to think about evolution of a project some time further.</p>
<p>Consider a situation with scripts. One might have a root-level directory called <code>scripts</code>, and the directory contains several files providing tools for CI/CD process, maybe tests, some pre- and post-install steps. That's a good example.</p>
<p>On the opposite, consider the same number of files but located under separate directories like <code>scripts/build/build.sh</code>, <code>scripts/install/install.sh</code>, and then <code>scripts/ci.sh</code> that sources those files. Don't do this.</p>
<p>Here's another example. Say we have an <code>http</code> directory. From here, we've got two options. If we know <em>for sure</em> that there will be no other networking stuff in the project any time soon (means a couple of years), then it makes sense to keep it simply as <code>http</code>. On the other hand, if there is a non-zero chance of implementing things for <code>smtp</code> and <code>dns</code>, then it does make sense to put it under <code>net</code>. Later, everyone will be happier with the structure because it reflects the nature of things and supports the purpose of the files.</p>
<p>At this point, it becomes clear that grouping for files and folders should be done based on its purpose. Even for non-code files.</p>
<h3 id="group-non-code-files-by-their-purpose"><a class="header" href="#group-non-code-files-by-their-purpose">Group Non-Code Files by Their Purpose</a></h3>
<p>Group and keep maintenance and routine files together by their purpose, in one or a few directories.</p>
<p>This helps in keeping the root level free from clatter, as well as reduces the time required to find a file when looking at the listing. You simply know where all your scripts reside, so no time and energy is wasted. When a new developer joins the project, they need minimal time to get an idea of what is where. Everyone is a bit happier.</p>
<p>As it was shown previously, group all scripts in the <code>scripts</code> directory. If there is plenty of them, and they're specific to the project itself (like startup scripts, init system scripts, cron files, etc), then it might make sense to keep the CI/CD stuff separately. Stay lean though, having <code>ci/scripts</code> and <code>scripts</code> is not a good sign. What else do you have for CI but scripts? If that's a couple of yaml files, let them stay under the same <code>ci</code> directory (see the previous point).</p>
<p>Nowadays many projects use Docker. If a project uses only one <code>Dockerfile</code>, and maybe one file for Docker Compose, then it's fine to keep them at the root. If you have multiple Docker files, and also have some scripts for building containers, then keep them grouped in a directory.</p>
<p>At this point, a valid concern may arise: if all those tools are in directories, it's less convenient to type commands in the terminal. This is what the next recommendation helps you with.</p>
<h3 id="provide-the-makefile"><a class="header" href="#provide-the-makefile">Provide the Makefile</a></h3>
<p>Provide the Makefile for a project to automate and simplify routine and maintenance tasks.</p>
<p>The <code>make</code> tool is available on almost any platform one can imagine, even on Windows without WSL. A minimal knowledge of the syntax of a Makefile is enough to produce a handy set of targets that simplify everyday workflows. The tool have existed for more than 44 years now, and it's likely to continue existing for another 40 years. And in the course of its life, the syntax hasn't changed very much. So it makes a lot of sense investing in learning it once, and benefit from it for the rest of your career.</p>
<p>Just to give you an idea how it can be helpful, consider several, rather basic, examples below.</p>
<ol>
<li>Building a binary.</li>
</ol>
<p>Without <code>make</code> and Makefile:</p>
<pre><code class="language-bash">GOOS=linux GOARCH=amd64 go build -ldflags &quot;-X main.revision=`git rev-parse --short HEAD`&quot; -o bin/my-app ./cmd/my-app
</code></pre>
<p>With <code>make</code>:</p>
<pre><code class="language-bash">make my-app
</code></pre>
<ol start="2">
<li>Building a container and running an app in it.</li>
</ol>
<p>Without <code>make</code>:</p>
<pre><code class="language-bash">docker-compose build --no-cache my-app
docker-compose up -d my-app
</code></pre>
<p>With <code>make</code>:</p>
<pre><code class="language-bash">make run-my-app
</code></pre>
<p>And so forth. While being basic, these examples make a huge difference in everyday experience.</p>
<p>To make your and colleagues' lives easier, define all routine tasks as targets in the Makefile. It can be then used not only by developers directly, but also  in your CI/CD scenarios. This makes the configurations clean, straightforward, and easy to understand and maintain.</p>
<p>It's important to give targets in the Makefile meaningful names. A meaningful name reflects the purpose and meaning of the operation it describes. When this is done well, instead of cryptic bash incantations your config for CI may look something like the one below. Pretty nice, isn't it?</p>
<pre><code class="language-yaml"># skipped

script:
  - make test
  - make cover
  - make build
  - make deploy

# skipped
</code></pre>
<p>We're almost done with common suggestions. Last in the list, but not the least in importance, is a piece of advice about storing credentials.</p>
<h3 id="store-credentials-somewhere-else"><a class="header" href="#store-credentials-somewhere-else">Store Credentials Somewhere Else</a></h3>
<p>Under no circumstance should you store any sensitive data in a repository, even if it's a private one. Just don't do that.</p>
<p>Don't add ssh keys, files with passwords, private ssl keys, API or any other credentials. It's alright if a repository contains those for development purpose. Anything else is a taboo. Good sleep at night is worth more than deceptive convenience of having production credentials committed to a repository.</p>
<p>What can be used instead? A private bucket in a block storage that contains an encrypted file with credentials might do a good job. A specialised service from your cloud provider of choice might help too. A special service running in your infrastructure that is responsible for storing and providing other services with sensitive data may be even a better option. But once again, do not store any credentials in a repository along with code.</p>
<hr />
<p>All these suggestions are supposed to help and support a team working with a project throughout its lifecycle. Considered and implemented carefully, they form a strong foundation for the project's success.</p>
<h2 id="library"><a class="header" href="#library">Library</a></h2>
<p>We create libraries for re-using in different places, projects, and by other people. The library's code is read more often than it's modified, simply because it's maintained by a limited number of people, whereas the number of users can be much higher. This is especially true for an open-source library. The library's code is consumed by a computer, but a person is the user and who interacts with it.</p>
<p>The layout of a library project should take these factors into account. This means that the layout needs to be optimised for interaction with the user, a person. We seek for answers in documentation, and read the code provided by a library to understand how it works. If a library is well-organised and neat, the process of using it smooth and unobtrusive.</p>
<p>So how can we make this interaction more positive from the layout perspective? If the <a href="u01-03-common.html#common">Common guidelines</a> are taken into account and implemented, that's mostly enough. They cover the most important aspects, and can and should be applied to a library project. Additionally, the following will help you in providing a better experience for the users of a library:</p>
<ul>
<li>providing a good README file</li>
<li>keeping the number of files at the top level of a manageable size</li>
<li>providing examples of using the library</li>
<li>providing benchmarking information, if applicable</li>
</ul>
<p>The rest of the section describes these suggestions in detail.</p>
<h3 id="provide-a-good-readme-file"><a class="header" href="#provide-a-good-readme-file">Provide a Good README File</a></h3>
<p>Provide a well-organised README file with the most important information about the library.</p>
<p>The README file should give answers to the following questions:</p>
<ul>
<li>What is it?
Provide a short description of the library. Ideally, one-two sentences.</li>
<li>What does it do?
Describe the problem the library is solving.</li>
<li>Why does it exist?
It should be clear why this library exists, especially if it's not the only library solving a particular problem. What does it do differently from others in its area?</li>
<li>How does it solve the problem?
Give the users an idea on what's going on under the hood, and what to expect from it.</li>
</ul>
<p>In addition to the above, the README should contain links to related resources like:</p>
<ul>
<li>the GoDoc page</li>
<li>any resources that describe details of algorithms or approaches taken in the library</li>
<li>articles or other resources that might be related to the topic.</li>
</ul>
<p>Your goal with the README file is to help your users in answering the most important question about the library: &quot;Does it help me in solving my problem?&quot;. Even if a library does solve a hard problem in a great way, if it isn't reflected in the documentation, that might be unnoticed, thus leading to less people using the library. A well-prepared README file helps your users to answer their questions.</p>
<h3 id="keep-the-top-level-list-of-a-manageable-size"><a class="header" href="#keep-the-top-level-list-of-a-manageable-size">Keep the Top-Level List of a Manageable Size</a></h3>
<p>Keep the root level list of files short and focused. While this sounds very similar to <a href="u01-03-common.html#keep-the-number-of-root-elements-at-minimum">this guideline</a>, it's worth a mention here.</p>
<p>Strive to keep the number of root elements such that it takes less than a full page height, so the user doesn't need to scroll to get to the README. It's also important when the user interacts with a library from their IDE. An endless list of files visually complicates navigation, and gives an impression of a poor organisation.</p>
<p>Additional recommendations will be given further in the unit about designing a good layout for a package.</p>
<h3 id="provide-examples"><a class="header" href="#provide-examples">Provide Examples</a></h3>
<p>In the README, provide clear examples of using your library.</p>
<p>A user should not be forced to go to the GoDoc page, or consult with the code on what using the library looks like. Think about possible use cases, and provide appropriate examples that show it.</p>
<p>Pay special attention to <em>how</em> you're showing the use of the library. Write high-quality code as if it was production code. A half, if not more, of the users will copy and paste code from the examples as it is given. So make sure the examples are not misleading, and do not contain things that you wouldn't want to find in your own production codebase.</p>
<p>Follow these suggestions in order to provide your users with good and quality examples:</p>
<ul>
<li>handle errors properly instead of omitting them</li>
<li>avoid globals as much as possible</li>
<li>avoid using the <code>init</code> function</li>
<li>use regular imports instead of dot-imports</li>
<li>handle errors properly instead of instead of <code>panic</code>-ing, <code>log.Fatal</code>-ing.</li>
</ul>
<p>This is not an exhaustive list, and more detail will be given in the unit about writing good code. But this short list is enough to make examples better, as well as the code that your users write.</p>
<h3 id="provide-benchmarking-results"><a class="header" href="#provide-benchmarking-results">Provide Benchmarking Results</a></h3>
<p>Provide benchmarks whenever possible.</p>
<p>When someone uses your library, it becomes part of their application. For those who do care about performance, it's important. Those who aren't interested in performance, will skip it. But those who are, will appreciate that. Oftentimes, performance is what differentiates one library from another, and the interested users would love to know about it.</p>
<p>Go provides us with all we need to write benchmarks, and to share the results with our users. So help your users in making the decision about the library, write and run benchmarks, and add the results to the README. Then, keep it up to date.</p>
<hr />
<p>The suggestions given above are simple, yet not always easy to follow. Take the time, make sure the project is prepared and organised. Eventually, the users of the library will find it helpful, and they will thank you for having done this for them.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Below you can find some examples of well-prepared libraries, and a few that could have been organised better.</p>
<h4 id="good-examples"><a class="header" href="#good-examples">Good Examples</a></h4>
<ul>
<li><a href="https://github.com/julienschmidt/httprouter">julienschmidt/httprouter</a></li>
<li><a href="https://github.com/dimfeld/httptreemux">dimfeld/httptreemux</a></li>
<li><a href="https://github.com/jmoiron/sqlx">jmoiron/sqlx</a></li>
<li><a href="https://github.com/rs/xid">rs/xid</a></li>
<li><a href="https://github.com/cryptowatch/cw-sdk-go">cryptowatch/cw-sdk-go</a></li>
</ul>
<h4 id="can-be-improved"><a class="header" href="#can-be-improved">Can Be Improved</a></h4>
<ul>
<li><a href="https://github.com/lib/pq">lib/pq</a>
While the README lists some features, it doesn't answer many questions, nor it gives us examples of using it, benchmarks, or any other information about why should we use it. The file organisation could also be improved.</li>
<li><a href="https://github.com/go-redis/redis/tree/v7">go-redis/redis</a>
As the number of Redis clients is relatively high, it would be valuable to provide users with comparisons and benchmarks that show the difference from other packages. Also, the structure of the repository can be better as not everything need to live at the root level of the package.</li>
</ul>
<h2 id="single-application"><a class="header" href="#single-application">Single Application</a></h2>
<p>A project (and its repository) for a single application is a further development of the guidelines given so far. Almost, if not everything, from the <a href="u01-03-common.html#common">Common</a> and <a href="u01-04-library.html#library">Library</a> sections can, and most likely, should be applied when working on a single service from the layout perspective. There are a couple of recommendations that make the experience better.</p>
<p>One distinction between a service and a library is that there is always at least one artefact, a binary. It also means that a project has at least one <code>main.go</code> file, which is not needed for a library. The experience of working on a project depends, to some extent, on where those files go.</p>
<p>The following will make interaction with a single-application project more convenient and easier:</p>
<ul>
<li>use a separate directory for entry points to the service and satellite tools/applications</li>
<li>use a special, excluded from Git, directory for outputting build artefacts.</li>
</ul>
<p>Next couple of sections go in expand the suggestions.</p>
<h3 id="use-cmd-directory-for-entry-points"><a class="header" href="#use-cmd-directory-for-entry-points">Use <code>cmd</code> Directory for Entry Points</a></h3>
<p>Use <code>cmd</code> directory for entry points to your service. Inside the directory, create a directory per each entry point, named after the application. The inner directories should mainly contain only one file, <code>main.go</code>.</p>
<p>Even when a project is a single application, oftentimes it has a number of satellite CLI and development tools, or different modes. Instead of a long list of <code>if</code> statements, this approach allows for small and focused, yet different entry points.</p>
<p>Create a directory named <code>cmd</code> at the top level of the file tree, and move any entry points, i.e. <code>main.go</code> files in to appropriate directories inside <code>cmd</code>. These second-level directories should be named as you want the binaries to be. Each of those directories is an isolated <code>main</code> package, hence a separate entry point to the app, defined in it.</p>
<h3 id="use-bin-directory-for-binaries"><a class="header" href="#use-bin-directory-for-binaries">Use <code>bin</code> Directory for Binaries</a></h3>
<p>Use <code>bin</code> directory for build artefacts. The directory must be excluded from the source control system. The directory is used in both development and CI processes.</p>
<p>As you remember, there should be no garbage in a repository. A binary that is built during development process should not appear among committed content.</p>
<p>Usually, a binary is excluded by listing its name in the <code>.gitignore</code> file. While this gives an immediate result and may work, it doesn't mean there is no a better option. This approach is not scalable. If someone builds the service with a custom name for the binary, the output can be accidentally committed. The same with CI, the process will just put files right at the root level.</p>
<p>A way to improve the situation is to have a separate directory in the project which is:</p>
<ul>
<li>excluded from Git</li>
<li>managed (created and cleaned) automatically</li>
<li>and used by both developers and build tools.</li>
</ul>
<p>The special directory is named <code>bin</code>, and its place is at the root level. The entire directory is excluded from Git.</p>
<p>Then, since the <a href="u01-03-common.html#common">Common</a> recommendations are in effect, you've got the Makefile. Given the previous tip, the targets work like this:</p>
<ul>
<li>inputs are taken from the <code>cmd</code> directory, e.g. <code>cmd/my-app</code></li>
<li>binaries are put to the <code>bin</code> directory, e.g. <code>bin/my-app</code></li>
</ul>
<p>Combined together, we get:</p>
<pre><code class="language-bash">go build -ldflags &quot;-X main.revision=`git rev-parse --short HEAD`&quot; -o bin/my-app ./cmd/my-app
</code></pre>
<p>If the directory doest not exist, make sure it's created as needed. When you do <code>make clean</code>, the target should remove everything from that directory.</p>
<p>All targets in the build or testing pipelines also use this path for outputting and accessing binaries. When running the service locally, you run it from the directory. Nice and tidy: <code>bin/my-app</code>. If typing in extra characters is a concern, define a target the Makefile, and use <code>make run-my-app</code>. Having this as a target is a scalable way since everyone in the team can use it. If need, you can also create a shell alias as <code>alias run-my-app='make run-my-app</code>.</p>
<p>The targets used in CI process also use the <code>bin</code> directory for artefacts, and then packaging and deploy steps seek for the artefacts in there. The process is structured and organised.</p>
<p>Having a separate directory for binaries is important because chances of multiple binaries are very high. One popular scenario is when a developer works under macOS, and uses Docker. While local version is going to be built for the Mac, the Docker version is built for Linux, hence there are two different binaries already.</p>
<p>It's likely that sometimes there will be a need to build binaries for many systems locally. Thus, two entries should be present in the <code>.gitignore</code> file. Then, if a new binary is introduced later, it will be another two entries. That's already a lot to keep track of, and too many files are at the root level.</p>
<p>Instead, define the <code>bin</code>  directory once, add it to the <code>.gitignore</code> file, set up all appropriate targets in the Makefile to use the directory, and don't worry about it for the rest of the project's life.</p>
<hr />
<p>Here is how a single-application repository may look like with the two recent suggestions applied:</p>
<pre><code class="language-bash">â”œâ”€â”€ bin
â”‚Â Â  â”œâ”€â”€ example-agent
â”‚Â Â  â”œâ”€â”€ example-cli
â”‚Â Â  â”œâ”€â”€ example-devsrv
â”‚Â Â  â””â”€â”€ example-plugins
â””â”€â”€ cmd
    â”œâ”€â”€ example-agent
    â”‚Â Â  â””â”€â”€ main.go
    â”œâ”€â”€ example-cli
    â”‚Â Â  â””â”€â”€ main.go
    â”œâ”€â”€ example-devsrv
    â”‚Â Â  â””â”€â”€ main.go
    â””â”€â”€ example-plugins
        â””â”€â”€ main.go
</code></pre>
<p>As you see, the structure is organised in a good order, and easy to work with.</p>
<p>Even more important the <code>bin</code> and <code>cmd</code> directories are when a project contains code for multiple <em>different</em> services. In this case, it's a monolithic repository, and many people, potentially several teams, are working on it. All previously given recommendations work especially well with a monorepo. That's what we will talk about in the next section.</p>
<h2 id="monolithic-repository"><a class="header" href="#monolithic-repository">Monolithic Repository</a></h2>
<p><em>Warning:</em> Do not confuse a monolithic repository with a monolithic application. They're absolutely different things.</p>
<p>Unless you're in one of the <a href="https://en.wikipedia.org/wiki/Big_Tech">FAANG</a> or similarly-sized companies, or just don't like the idea, there are probably few technical reasons, if any, against using the <a href="https://en.wikipedia.org/wiki/Monorepo">monorepo</a> approach to organising a project that has multiple moving parts. And Go projects can benefit quite well from it.</p>
<p>Moreover, teams are likely to benefit from this technique as it has several strong supporting arguments like:</p>
<ul>
<li>simplified workflows for CI/CD and testing</li>
<li>reduced burden with managing internal dependencies</li>
<li>significantly less chores with permissions/access</li>
<li>unified tooling</li>
<li>easier to package/ship and so forth.</li>
</ul>
<p>Of course, there are some limitations and downsides, but they are not in effect until after at least a couple of hundreds of thousands SLOCs have been committed in a couple of millions of commits.</p>
<p>A valid concern may be access control, but that's only partially true. If the security policies at a company do make sense and implemented and respected well, there is little to worry about. Experience of companies for which security <strong>is</strong> the biggest asset, suggests that the attitude and mindset are what matter. When everyone is accountable for what they're doing, there is no need in introducing artificial barriers.</p>
<p>The decision on whether to use a monorepo or not is upon you, the reader. The goal of this section is not to make you use this approach, although it makes sense rather often than not. This work covers various aspects of software development, is based on experience, and provides practical advice and guidelines. Several services will be introduced in the third module (it's quite far from this point), and the materials <em>do use</em> a monolithic repository.</p>
<p>With that in mind, further we talk about how to structure a monorepo in a way that makes the experience of using it better. As there are several ways to approach organising a monorepo, and to understand what makes a good one, it's worth getting familiar with some of them. Finally, one reasonable approach will be introduced, and we'll learn more about it.</p>
<p>There is no official classification for monolithic repositories. Yet some of common traits can be derived after investigating and working with different projects. The experience shows that most of the time a monorepo is of one of the following types:</p>
<ul>
<li>naive</li>
<li>based on services</li>
<li>focused on entities.</li>
</ul>
<p>Let's have a quick look at these and consider their pros and cons. Then we introduce an alternative, the structured approach.</p>
<h3 id="naive-monorepo"><a class="header" href="#naive-monorepo">Naive Monorepo</a></h3>
<p>A naive monorepo is exactly what its name says. It's what usually happens when a team decides to use a monorepo, without taking the time to learn and putting a good thought into how to make it work:</p>
<ul>
<li>a new repository is created</li>
<li>then each of the existing services is copied over to the new repo, as is</li>
<li>done</li>
<li>alternatively, everything can be moved into one of the existing repositories, but this doesn't do much of a difference.</li>
</ul>
<p>As a result, the team got just a rather large directory with lots of semi-independent parts, lots of duplicated scripts, files, words, whatnot. One of the immediate benefits <em>seems to be</em> that now something from service A can be imported by service B, but this will quickly become troublesome, especially if the original repositories did not follow the suggestions (such as) listed above, which is highly likely.</p>
<p>This approach has many downsides. Besides being messy and containing many duplications, it is the shortest path to creating dependency cycles. This can often lead to either a poor hierarchy and structure that is created just for the sake of breaking a cycle, or even to concluding that the monorepo was a mistake, and should be avoided. Neither of the those leads to productive and efficient collaboration.</p>
<p>It's hard to justify following this way. Instead, plan the migration, and then execute the plan iteratively. You need to come up with a good structure that suits well and will serve your needs for years. Don't rush, think, plan, try, and only then execute. Not the other way around.</p>
<p>After having realised that this way is not better than it was before the move, the team may decide to organise the repository somehow. One of obvious ways is to use a service as a boundary and splitting criterion. This is how a naive monorepo may evolve to a service-based one.</p>
<h3 id="service-based-monorepo"><a class="header" href="#service-based-monorepo">Service-Based Monorepo</a></h3>
<p>The service-based approach is a slight improvement of naive. The main difference is that some of the duplicated components among services are unified, e.g. CI and building routines, but the codebase continues using services as boundaries for packages. Put simply, each folder at the root level contains a service along with everything that's in the service's scope - data types, business and transport logic, etc. When a service needs something that's already implemented somewhere, it just imports that. New functionality is being developed within the boundaries of a service.</p>
<p>While it might work for some time, such a repository still has exactly the same major downside as naive - it's too easy to end up with a dependency cycle, more so when you try to re-use some code with business logic. Also, there isn't much of an order, since data, logic and utility code are spread across the entire codebase.</p>
<p>A few other serious downsides enter the stage at this point, caused by importing different parts of various services:</p>
<ul>
<li>increased sizes of binaries</li>
<li>increased compilation times</li>
<li>not always clear what to do with tests.</li>
</ul>
<p>As the project evolves, it might seem natural to think of grouping code based on entities it belongs to. Here is how a monorepo may transform into entity-focused.</p>
<h3 id="entity-focused-monorepo"><a class="header" href="#entity-focused-monorepo">Entity-Focused Monorepo</a></h3>
<p>The entity-focused technique is organising code around a particular entity. Packages are often created for different units of the business domain of a project, such as <code>user</code>, <code>photo</code>, <code>library</code> and so forth. Developers add logic into appropriate packages, and then use it in services.</p>
<p>This approach is a bit better than the previous two. It allows for working on services' part separately from the business logic, if implemented correctly.</p>
<p>Still, there are two potential problems:</p>
<ul>
<li>different levels of representation and responsibility could be mixed together, such as data types, methods for accessing storage, business logic and transport details</li>
<li>a major risk in creating cycles, specifically at three levels:
<ul>
<li>entity - when several entities depend on each other</li>
<li>business logic - when a business process depends on the logic of several entities</li>
<li>transport and representation - when representations of several entities/processes depend on each other.</li>
</ul>
</li>
</ul>
<p>The second issue comes from a fact that it's rare for entities, business logic and their representations to be independent from each other, i.e.:</p>
<ul>
<li>entities often aggregate or are parts of other entities</li>
<li>business logic for one process depends or is included into another process</li>
<li>representation for one area of the domain requires other parts.</li>
</ul>
<p>Is there a solution to address these and the problems described above? How to organise a repository in a way which reduces the dependency cycle risk to a minimum (or better to zero)? How to organise a repository in a way when it's easy to re-use entities and logic in different services? How to make developers happier, and services better organised?</p>
<p>The first problem is to be addressed by making better package and architectural design decisions. The former is the subject for Unit 2 in this module, the latter is the topic for Module 3. Some suggestions will be given shortly, in the very next section.</p>
<p>There is no ultimate solution, of course. But there is an option which, if implemented carefully and everyone respects the process, can help to achieve better efficiency and maintainability.</p>
<h3 id="the-structured-monorepo"><a class="header" href="#the-structured-monorepo">The Structured Monorepo</a></h3>
<p>The structured approach is based on grouping code by responsibilities, and levels where objects play their roles. In other words, things are put together by what they do and where they belong:</p>
<ul>
<li>data layer (models)</li>
<li>database layer (repositories)</li>
<li>business processes (controllers)</li>
<li>transport representations (handlers) and so on.</li>
</ul>
<p>By doing this way, we avoid problems described above, and get some additional benefits:</p>
<ul>
<li>at the model level, any model can safely relate to another</li>
<li>at the business process level, any process is free to do the following, without the risk of introducing a cycle:
<ul>
<li>use any model or combine multiple</li>
<li>include any other business process, or be included in other business process, as a step</li>
<li>interact with database representations for the models it works with</li>
</ul>
</li>
<li>similarly, at the transport level, any service can use or combine various business processes, and more.</li>
</ul>
<p>The insightful reader might have already noticed that this has many similarities with properly designing and structuring a good single service. Moreover, if a single service has followed this way, adding another service wouldn't even require to do anything, since the project, hence the repo, is already prepared to accommodate as many applications as needed.</p>
<h3 id="the-layout-of-a-structured-monorepo"><a class="header" href="#the-layout-of-a-structured-monorepo">The Layout of a Structured Monorepo</a></h3>
<p>Everything that has been discussed about different layouts so far comes together and applies to a monolithic repository. Taken into account, implemented and followed carefully, the practices establish the foundation for a good monorepo.</p>
<p>This is what a project may look like at this point:</p>
<ul>
<li>the documentation is provided and up to date</li>
<li>the list of elements at any level is of a reasonable size</li>
<li>all maintenance scripts and other non-code files are organised</li>
<li>the entry points to services are located in the <code>cmd</code> directory</li>
<li>the binaries automatically go and picked up from the <code>bin</code> directory</li>
<li>code that implements the project's data and logic is grouped by responsibilities and roles.</li>
</ul>
<p>A few questions inevitably arise while working on a reasonably large project within one or a couple of teams:</p>
<ul>
<li>Where do we put code that is meant to be used by many services?</li>
<li>Where should utility code go?</li>
<li>How to gradually and safely introduce something new or a breaking change?</li>
</ul>
<p>There is no simple and direct answer. It's also where good planning and thinking should be done, as well as some exceptions. With that in mind, let's consider the following suggestions that help to keep things at the right places:</p>
<ul>
<li>use appropriate position at the file tree to reflect the importance of a package</li>
<li>organise utility code as own small standard library</li>
<li>keep breaking changes in sandbox.</li>
</ul>
<h4 id="use-appropriate-position-at-the-file-tree"><a class="header" href="#use-appropriate-position-at-the-file-tree">Use Appropriate Position at the File Tree</a></h4>
<p>Place packages appropriately in the file tree of a monolithic repository to reflect the importance and nature of a package.</p>
<p>What does it mean and what properties can we use to determine a right placement of a package? There's no hard set of rules. The following heuristics can help in understanding where a package should be placed:</p>
<ul>
<li>An approximate position of a package in the dependency graph.
A package that is imported by many other different packages should be located closer to the root of the hierarchy. A rarely imported package is most likely an implementation detail, and should go deeper in the tree.</li>
<li>The frequency of use.
The position of a package is in direct proportion to of how frequently the package is used.</li>
<li>The importance of a package.
Something that is unique, and provides and implements an important piece of functionality should be placed closer to the top.</li>
<li>The level of abstraction and role.
The higher the abstraction, the higher the level at which a package should be placed.</li>
</ul>
<p>For example, a package with code for converting internal errors from their internal representation to the external, and which is used by the most of the packages that implement application functionality, should be placed at the top level of the structure.</p>
<p>Another example is the packages that <em>are</em> the definitions of the business logic  - packages with models, controllers, and the database layer.</p>
<p>On the other hand, a set of middleware handlers for an API should be located deeper in the tree, as it's used only in the context of API, and only by an instance of API. Similarly, routines for data validation, migrations, etc are better to be placed at the second or third level of the tree.</p>
<p>More on this to come in later units covering package design and architecture of a service.</p>
<h4 id="organise-utility-code-as-own-standard-library"><a class="header" href="#organise-utility-code-as-own-standard-library">Organise Utility Code as Own Standard Library</a></h4>
<p>Organise, treat, and maintain all utility code as a small private extension to the standard library. If possible, consider releasing it open source.</p>
<p>This recommendation sounds controversial, and needs further explanations. To understand it better, we first need to clarify what differentiates utility code from other, and then go deeper into how to apply it in real life.</p>
<h5 id="utility-code"><a class="header" href="#utility-code">Utility Code</a></h5>
<p>Utility code is code that implements technical details of a process, and is <strong>independent</strong> from the business logic of a project. The independence from the business logic is the crucial part that distinguishes utility code from any other.</p>
<p>The following traits are common for utility code:</p>
<ul>
<li>it's independent from any other code besides the standard library and/or itself</li>
<li>most of the methods operate on built-in types, or on the types from the standard library</li>
<li>provides common and often used routines</li>
<li>it can be extracted as a separate library</li>
<li>it can be open sourced</li>
<li>provides methods that do not exist in the standard library.</li>
</ul>
<p>Here are some examples of code that can be part of a private extension to the standard library:</p>
<ul>
<li>managing the lifecycle of a process, including proper signal handling, graceful and forced shutdown</li>
<li>archiving/compressing directories</li>
<li>extended configuration and methods for the <code>http.Client</code>, such as custom transports, file downloading, etc</li>
<li>handling multipart uploads</li>
<li>advanced strings manipulation</li>
<li>some standard and generic data structures and algorithms, such as queues, graphs, lists, and so forth</li>
<li>concurrency patterns</li>
<li>file tree traversing utilities and so forth.</li>
</ul>
<p>Having clarified what utility code is and what is not, we can discuss what to do with it.</p>
<h5 id="details-and-discussion"><a class="header" href="#details-and-discussion">Details and Discussion</a></h5>
<p>To begin with, it's worth reminding one of the most often repeated mantras in the Go community:</p>
<blockquote>
<p>Prefer duplication over the wrong abstraction.</p>
<p>â€“ Sandi Metz, and many gophers.</p>
</blockquote>
<p>This is true, and this section should not be considered as something opposite. The author is one of those who respects and follows this advice.</p>
<p>Nonetheless, many rules do have exceptions. It's more about finding what works. What is good for a small project/service, can be a poor choice when applied to multiple services. What's good at a small scale, can significantly complicate things at a larger, and vice-versa.</p>
<p>The definition of utility code given above implicitly prohibits building additional abstractions on top of the standard library code. It can be only considered as an extension.</p>
<p>Duplication works well for a small service, when a small team maintains a couple of medium-sized services. In other words, duplication suits well when it's used moderately and rarely, and in isolation.</p>
<p>Things are different in a project that is supported by one large or several teams, when it's a monorepo, when the number of services grows. The duplication approach is not scalable. Employing it at a larger scale leads to <em>unnecessary</em> duplications, mess in codebase, lack of guarantees, and makes the project prone to errors. The quality of testing decreases.</p>
<p>One of the biggest strengths of Go as a programming language, is that there is mostly one way for accomplishing a task. It becomes almost a requirement when working with many services. There should be <em>only</em> one way to download a file, zip or unzip a directory, parse an authentication header and so forth. Failing to acknowledge this can turn out to be a major source of obscure and nasty bugs at later stages of a project.</p>
<p>So when a project is a monorepo, and has more than one service, the following is true about utility code:</p>
<ul>
<li>it will inevitably occur</li>
<li>it should be reliable and trustworthy</li>
<li>it should be tested</li>
<li>it should be maintained</li>
<li>it should be standardised.</li>
</ul>
<p>One of the ways to provide these guarantees is to have such code in one place, and being conscious about and responsible for it.</p>
<h5 id="in-practice"><a class="header" href="#in-practice">In Practice</a></h5>
<p>The guideline can be simply employed like this:</p>
<ul>
<li>at the root level, have the <code>lib</code> directory as home for utility code</li>
<li>put packages inside <code>lib</code></li>
<li>for packages those names clash with ones from the standard library, add a prefix, for example, <code>x</code>, <code>xstrings</code></li>
<li>alternatively, keep names for packages as is, but have an agreement on how a custom package should be named when imported along with a package from the standard library with the same name. Do not use custom names for the standard packages, ever.</li>
</ul>
<p>This approach also works especially well when implementations of some routines are different between the platforms your project supports.</p>
<p>As a result, the file tree may look like this:</p>
<pre><code class="language-bash">â”œâ”€â”€ bin
â”œâ”€â”€ cmd
â””â”€â”€ lib
    â”œâ”€â”€ process
    â”‚Â Â  â”œâ”€â”€ process.go
    â”‚Â Â  â”œâ”€â”€ process_darwin.go
    â”‚Â Â  â”œâ”€â”€ process_linux.go
    â”‚Â Â  â”œâ”€â”€ process_posix_test.go
    â”‚Â Â  â”œâ”€â”€ process_windows.go
    â”‚Â Â  â””â”€â”€ process_windows_test.go
    â”œâ”€â”€ files
    â”‚Â Â  â”œâ”€â”€ files_posix.go
    â”‚Â Â  â”œâ”€â”€ files_test.go
    â”‚Â Â  â””â”€â”€ files_windows.go
    â”œâ”€â”€ http
    â”‚Â Â  â”œâ”€â”€ http.go
    â”‚Â Â  â””â”€â”€ http_test.go
    â”œâ”€â”€ os
    â”‚Â Â  â”œâ”€â”€ os.go
    â”‚Â Â  â”œâ”€â”€ os_posix_test.go
    â”‚Â Â  â””â”€â”€ os_windows_test.go
    â””â”€â”€ strings
        â”œâ”€â”€ strings.go
        â””â”€â”€ strings_test.go
</code></pre>
<p>When applied and followed carefully, this advice helps to consolidate and maintain low level code, providing one way for accomplishing a particular task, giving more guarantees about the quality and correctness of the implementation, and reducing the maintenance cost.</p>
<h4 id="have-sandbox-for-breaking-changes"><a class="header" href="#have-sandbox-for-breaking-changes">Have Sandbox for Breaking Changes</a></h4>
<p>Another important aspect that is different when working with a monolithic repository, is introduction of breaking changes, or entirely new code that is not proved to be stable. Within a monorepo, a piece of code is relied upon potentially in hundreds of places, so it's better to test a change in isolation, and only then use elsewhere. How do we do about it in a monorepo?</p>
<p>In a monorepo, have a special place for adding potentially unstable code. An <code>experimental</code> or <code>unstable</code> directory at the root level would be a good choice. Then, inside that directory, follow similar structure as if it were the root level.</p>
<h5 id="details-and-discussion-1"><a class="header" href="#details-and-discussion-1">Details and Discussion</a></h5>
<p>In a classic scenario, dependency management tools usually solve this problem. A dependency that is used in many places, is updated, and the change is then gradually introduced. Go modules and/or vendoring are handy tools here, and this is one of the main reasons for their existence.</p>
<p>However, these tools are not available anymore for addressing this problem as all code is in a single repository. At least, not directly. It's impossible to vendor a part of a repository, or use a separate import path for a package that is part of a large module.</p>
<p>A solution to this problem has existed for many years, and is in use by various kinds of software, from private projects to the Linux kernel, and many established Linux distributions and software. A common name for the solution is &quot;experimental&quot;.</p>
<p>What do we mean by &quot;experimental&quot;?</p>
<p>Of course, there are different stages in release processes, such as development, alpha and beta versions, release candidates and so on. Somewhere between development and beta there is usually an experimental branch, or a stage. After reaching some level of stability, the project transitions to next stage, usually testing, or beta. This is followed by many projects, yet it's not exactly what current advice is about.</p>
<p>This guideline is about having experimental code included in the stable version, and made available for conscious use. If the reader have ever configured and compiled a Linux kernel, they would recall the <code>EXPERIMENTAL</code> label for drivers that are included in a stable release, but are still in active development, and included for use as is, without any guarantees.</p>
<p>Similarly, even the most stable version of Debian and many other Linux distributions have an <code>experimental</code> section in their repositories, which contain early releases of software. Such sources are turned off by default, but the user is free to use it.</p>
<p>So here's what to do in a monorepo. When introducing a breaking change or something entirely new, and such code is not guaranteed to work or work correctly (hence it's not for general use), consider this:</p>
<ul>
<li>add a package for new code, if it doesn't exist yet, to the <code>experimental</code> or <code>unstable</code> directory</li>
<li>add new code to the package</li>
<li>use it, test it, change it, prove it works</li>
<li>once confirmed working:
<ul>
<li>for new code, move it to the stable tree</li>
<li>for changes to existing code, depending on the situation
<ul>
<li>move changes to the stable tree and make necessary adjustments</li>
<li>alternatively, use type aliases to redirect uses from old code to new
<ul>
<li>test and prove it works</li>
<li>move changes to the stable tree.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>An important note about the process is that the <code>experimental</code>/<code>unstable</code> tree must be kept in a good order at all times. As with utility code, without discipline, it's too easy to let these places become junk yards. Keep them clear from clutter by making sure everyone on the team is following conventions and the boy scout rule, move working code to the stable tree, eliminate unused and incorrect code.</p>
<h2 id="monorepo-additional-chapters"><a class="header" href="#monorepo-additional-chapters">Monorepo: Additional Chapters</a></h2>
<p>The approach to maintaining a monolithic repository outlined above is a good starting point, and works quite well in most cases. At the same time, larger organisations with a larger number of teams and services, may want or need more flexibility when working with a monorepo. Let's think of potential reasons for that, and how to address the needs.</p>
<h3 id="open-questions"><a class="header" href="#open-questions">Open Questions</a></h3>
<p>What questions are left with no answers by the structured monorepo? Some of them include:</p>
<ul>
<li>What if we need to maintain both, older and newer versions of a package?
For example, this could easily be the case when a large number of services work with the same model, say a core business unit. You have to update the model, you tried to find a way to make a backward and forward-compatible change, but it seems to be either impossible or too resource demanding. Had this model been in a separate module, a new major version with a breaking change could have done the job. But with a monorepo, everything is versioned as a whole, or not versioned at all.</li>
<li>What if some packages are changed too often, such that it's hard for other teams to keep their services up to date with the changes? Or, how to allow quick and frequent changes in code that is relied upon by other code?
While this should not be normally the case in a well-designed system, this happens. There might be places in a codebase which are depended upon by hot execution paths, and for some reason changes to them are made quite often. If several teams are forced to perform routine updates caused by the work of another team, this can quickly become a major bottleneck, a source of anxiety and even lead to a (rather wrong) conclusion that monorepos don't work.</li>
<li>What if infrastructure and utility code changes often enough to bother other teams with the need to keep their services up to date?
Similarly to the previous question, this normally should not happen. Yet, sometimes this happens, especially when the initially written low-level code is not optimal (someone quickly prototyped, and forgot to finalise the work by taking the draft to a solution that is done well), and at some point it needs to be refactored. In such case, there <em>will</em> be breaking changes, and having everything in a single repository dictates the need to adjust all depending services at the same time.</li>
<li>What if all of the above is the case, the number of people working on a project is large, as well as the codebase, which is slightly aged and has got a fair amount of legacy in it?</li>
</ul>
<p>These are just a few questions that you may have, either because it's your case, or you know someone who is in a similar situation, or for any other reason. There are, of course, many other potential questions. Our goal here is not to find a silver bullet that is the ultimate answer to these and all other questions. Instead, we're trying to find out something to start with, where you can begin experimenting and working out your own way.</p>
<p>Further we consider two additional options that you can employ to help in maintaining a healthy monolithic repository as well as to keep your teams happy and efficient, as much as it is possible in this context. It's advised to use them only when the structured approach is not enough, and it has either already limited you in some way, or the analysis shows some evidence that it might happen soon, and other changes have been tried to improve the situation.</p>
<p>As with everything in life, any flexibility comes at a cost of increased complexity and responsibility, and you have to keep the latter two in balance. Abusing the complexity, or neglecting the responsibilities are two of the most common reasons for any failure, especially and very often it is the case in software development.</p>
<p>Having put an extra stress on the importance of being cautious with added complexity, let's look at ways for achieving additional flexibility. The first one offers the use of nested Go modules, and the second is a bit more radical, but still an option for situations when changes happen too often, and are too breaking. And finally, we look at the combination of the two.</p>
<p><em>NOTE: In the context of the next section we use the term &quot;nested modules&quot; for a Go module that is located not at the root of a repository, potentially having siblings in neighbour directories. We deliberately refrain from using the term &quot;submodule&quot; to avoid confusing it with a Git submodule. Git submodules are not considered in and are outside of the scope of the book.</em></p>
<h3 id="more-structure-with-nested-modules"><a class="header" href="#more-structure-with-nested-modules">More Structure with Nested Modules</a></h3>
<p>Consider converting the top-level packages into nested modules when need more fine grained control and flexibility over packages' lifecycle.</p>
<p>This is possible because Go modules support nested modules, which are sometimes referred to as submodules.</p>
<p>As you know, a Go module is identified by the <code>go.mod</code> file. Each module must have this file, and it's location defines the root of the module. While it is the most often use case, and it is strongly advised to have a single module per repository located at the root, it's possible to maintain multiple modules under the same repository. It's also possible to version nested modules independently using Git tags of a slightly different form.</p>
<p>In general, the technique works as follows:</p>
<ul>
<li>some of the top-level packages are separate modules</li>
<li>each such package, i.e. module, is versioned separately</li>
<li>each module can import another module, as if it was just a package</li>
<li>following the conventions set by semantic versioning is mandatory, i.e. each breaking and incompatible change requires a new major version of such module
This allows the use of a separate import path by the code that is interested in the newest version, while the code that is yet to be updated continues using the older version.</li>
</ul>
<p>Now let's look at an example. Here, we have a monolithic repository called <code>monorepo</code> owned by the <code>myorg</code> account. In the repo, we've got two packages - <code>model</code> and <code>controller</code>. Everything up until now has been as a single module, defined at the root of the repository. Our task is to convert the two packages into nested modules, and to version them independently. The execution plan consists of three steps, for each package:</p>
<ul>
<li>initialise a module</li>
<li>commit and push changes to the remote origin</li>
<li>version the new module by creating and pushing a tag, paying special attention to the name of the tag, it's <code>module_name/vX.Y.Z</code>, not just <code>vX.Y.X</code>.</li>
</ul>
<p>The final directory structure looks like this:</p>
<pre><code class="language-bash">.
â”œâ”€â”€ controller
â”‚Â Â  â”œâ”€â”€ controller.go
â”‚Â Â  â””â”€â”€ go.mod
â”œâ”€â”€ model
â”‚Â Â  â”œâ”€â”€ go.mod
â”‚Â Â  â””â”€â”€ model.go
â””â”€â”€ go.mod
</code></pre>
<p>Let's go look at each step in detail for each of the two packages, starting with <code>controller</code>. For simplicity, we omit creating a separate branch and pull request:</p>
<ul>
<li>first, convert the <code>controller</code> package into module</li>
</ul>
<pre><code class="language-bash">cd controller
go mod init github.com/myorg/monorepo/controller
</code></pre>
<ul>
<li>now commit and push the change</li>
</ul>
<pre><code class="language-bash">git add go.mod
git commit -m &quot;Convert controller package to module&quot;
git push
</code></pre>
<ul>
<li>next, version the module by creating a tag</li>
</ul>
<pre><code class="language-bash">git tag -a controller/v0.1.0 -m &quot;Convert controller to module&quot;
git push --tags

# OR
git push -u origin controller/v0.1.0

cd ..
</code></pre>
<p>Now we handle the <code>model</code> package, assuming it's version is somewhat bigger:</p>
<ul>
<li>convert it into module:</li>
</ul>
<pre><code class="language-bash">cd model
go mod init github.com/myorg/monorepo/model
</code></pre>
<ul>
<li>commit &amp; push</li>
</ul>
<pre><code class="language-bash">git add go.mod
git commit -m &quot;Convert model package to module&quot;
git push
</code></pre>
<ul>
<li>finally, version the module</li>
</ul>
<pre><code class="language-bash">git tag -a model/v0.4.1 -m &quot;Convert model to module&quot;
git push --tags

# OR
git push -u origin model/v0.4.1

cd ..
</code></pre>
<p>And that is it.</p>
<p>This approach allows for versioning packages within the monorepo independently. The biggest advantage is that you can now easily introduce a breaking change under a new major version, starting from <code>v2.0.0</code>. A detailed conversation about versioning Go modules is the subject for next section, right after we finish with monolithic repositories.</p>
<p>All above is, of course, good, but what if you're larger than Google, and one monorepo is too limiting for your needs, or for some other reason the options discussed so far offer not enough flexibility? Well, would two or more monolithic repos help you?</p>
<h3 id="multiple-monorepos"><a class="header" href="#multiple-monorepos">Multiple Monorepos</a></h3>
<p>In a perfect world, and for some teams, a single monorepo works absolutely well. But what if your reality is somewhat less than ideal, and one monolithic repository is not enough? If a single repository is too limiting or restrictive, that is probably not a sign that it does not work. Perhaps you just need opt for two or more monorepos, each carrying unique responsibilities.</p>
<p>We leave aside some obvious and legit cases where a large organisation has several monolithic repositories as a matter of separation of concerns. For example, one company acquires another, and the two companies under the same roof continue development in two monorepos. Legal concerns might be involved too, so this is an absolutely natural reason for multiple monorepos.</p>
<p>Similarly, we leave aside situations where a company starts experimenting in a new field, or a new project. For example, it's natural for a game studio to develop each game in a separate repository.</p>
<p>Nonetheless, there are questions that some may want to ask. What if, for example, the infrastructure-specific code is evolving too quickly? Or what if CI/CD workflows for client and service code are too different? What if services in the monorepo use so different technologies that it somehow resulted to incompatible workflows? Or, what if one team wants to follow GitHub Flow, and the other is willing to follow Git Flow? What if one team is simply not willing to adapt the practice?</p>
<p>The questions above, although sounding real, are a subject to the overall engineering policy and culture at an organisation. Normally, an organisation has some sort of shared vision where everyone is aligned with and agreed on the foundational principles, approaches and tooling. So if those sorts of questions are present within your organisation, and everyone is doing whatever they want, that's probably a topic for a separate conversation. Here we focus on the technical aspects of dealing with a problem where one monorepo is not enough. And while the author has failed to find an example of a real reason for this (besides a few mentioned earlier and the likes), it should not prevent us from exploring what's available.</p>
<p>Below we briefly explore several available combinations for consideration should you need this. It's obvious that all options that are mentioned, as well as anything that you come up with, have pros and cons, and here are a few common. Unless given explicitly, a common advantage is increased flexibility, either technical or organisational/legal, which comes at a cost of the downside in a form of exponentially increased complexity, and increased cost of maintenance. Instead of reducing entropy and chaos, they facilitate it.</p>
<p><em>NOTE: Bear in mind that the options explored further won't work for all teams, and finding a silver bullet is not the goal of the exploration. It should be clear that no one is enforcing anything upon the reader. Some teams consist mostly of full stack developers, while others prefer specialised engineers. Therefore, it's obvious what is good for one case, might not work for another.</em></p>
<h4 id="multiple-single-module-monorepos"><a class="header" href="#multiple-single-module-monorepos">Multiple Single-Module Monorepos</a></h4>
<p>A simplest option, if applying this adjective is even possible once we're here, is to have a few monorepos that follow the structured approach described in detail earlier in the unit.</p>
<p>It's relatively straightforward, and enables for easier separation of concerns. This option might suit for cases when code needs to be split for both, legal and technical reasons, when alternatives are somewhat less optimal.</p>
<p>It might also be helpful when there is a strong desire or need in splitting utility code from business logic code. In such situation, the monorepo with utility code becomes an official in-house extension to the standard library, and the monorepo with business logic and services is focused only on the company's business domain.</p>
<h4 id="architectural-monorepos"><a class="header" href="#architectural-monorepos">Architectural Monorepos</a></h4>
<p>Another option is splitting all code into few layers, and put each layer into a separate monolithic repository.</p>
<p>A large organisation may have a huge project, or many projects, each of them have at the very least three major components: infrastructure, client-side and services. In such case, it might make sense to organise code as follows:</p>
<ul>
<li>all infrastructure and operations code lives in one monorepo</li>
<li>the second monorepo is devoted to client code
<ul>
<li>it's also possible to go further and split web clients from mobile, if needed</li>
</ul>
</li>
<li>finally, the code that is responsible for handling and persisting data, i.e. services, goes into its own repository.</li>
</ul>
<p>With this setup, all major components are split by their nature, and this might be beneficial for the teams, and processes.</p>
<h4 id="technology-specific-monorepos"><a class="header" href="#technology-specific-monorepos">Technology-Specific Monorepos</a></h4>
<p>An organisation may have hundreds of thousands lines of code written using one technology stack, i.e. language, and then switch to another, producing another hundreds of thousands of lines of code, or millions. And while this is not necessarily a goal on its own, it might be beneficial to split code into monolithic repositories focused on a specific technology.</p>
<p>This option may work quite well when a company is transitioning from one stack to another, or works with several in parallel. Go code stands out in that it's much easier to support compared to other languages, besides maybe a case when you have no code at all. So it might be reasonable to put all Go code in a separate repository, and say C++ code in another, and then Javascript in the third.</p>
<h4 id="multiple-monorepos-with-nested-modules"><a class="header" href="#multiple-monorepos-with-nested-modules">Multiple Monorepos with Nested Modules</a></h4>
<p>Potentially the highest degree of flexibility, along with complexity and chaos, can be achieved by employing multiple monolithic repositories with multiple independently versioned modules in them.</p>
<p>It's strongly advised against using this option, but it's still available. If your organisation is ready to pay the price of this flexibility, or if there is a real need in it (which is highly unlikely), then this is technically possible, and, with very high levels of personal responsibility of each individual and collective responsibility of the engineering department as a whole, might work. Depends on you.</p>
<h3 id="closing-notes"><a class="header" href="#closing-notes">Closing Notes</a></h3>
<p>Maintaining a monolithic repository that several teams are working with, is not an easy task. The experience shows that this is not only possible, but is also highly beneficial when approached consciously and organised, when the vision is shared by everyone involved in the process, when the culture is strong, and people understand the importance of keeping things in a good order.</p>
<p>The techniques described in this section are not new, unique, silver bullet, nor a panacea. But they have proved to be helpful for projects of various sizes, in small and larger teams. Give it a go, experiment, adjust to your needs, and find what works and what does not.</p>
<h2 id="versioning-and-go"><a class="header" href="#versioning-and-go">Versioning and Go</a></h2>
<p>The unit won't be complete without considering such an important topic as dependency management, versioning and distribution in the context of the project layout. Thankfully, in Go this is addressed mostly with one of the most significant changes over last several years which is Go Modules.</p>
<p>Although Modules was released more than 2 years ago, many individuals and companies have only started adopting them. Partially this is due to laziness that is often masked under complains about lack of documentation. There is, actually, lots of high quality content on the topic, as Russ Cox published <a href="https://research.swtch.com/vgo">an extensive and exhaustive set of articles on his blog</a> while Modules were going from the proposal to the final release. Partially this is due to a generally slow adoption process when something new is introduced.</p>
<p>Anyway, over the course of last year, the situation with documentation has significantly improved. One of the best resources so far is <a href="https://github.com/golang/go/wiki/Modules">the Go Modules section</a> on the official Go Wiki. Yet, developers are often not confident when it comes to either performing a major dependency update, or releasing a major version. Many projects are still using <code>dep</code>. And while there is nothing wrong with <code>dep</code> or the use of it, the tool is now obsolete, and it will be restricting its user in many ways. So it's better to migrate to Modules, and benefit from what Go has to offer.</p>
<p>This section summarises the learnings and experience gathered since when Modules were first mentioned. If you've already read all of the official materials mentioned above (Russ's posts and all posts in the official Go Wiki and blog), then you probably learn a little from the section. However, there is some practical advice that might be useful. And given the current module is called &quot;The Style Guide&quot;, consider everything below as a recommendation.</p>
<p>The outline:</p>
<ul>
<li><a href="u01-08-versioning-and-go.html#notes-on-terminology">Notes on Terminology</a>
<ul>
<li><a href="u01-08-versioning-and-go.html#the-main-branch">The Main Branch</a></li>
<li><a href="u01-08-versioning-and-go.html#the-default-branch">The Default Branch</a></li>
</ul>
</li>
<li><a href="u01-08-versioning-and-go.html#prerequisites-and-assumptions">Prerequisites and Assumptions</a></li>
<li><a href="u01-08-versioning-and-go.html#approaches-to-versioning">Approaches to Versioning</a>
<ul>
<li><a href="u01-08-versioning-and-go.html#review">Review</a></li>
<li><a href="u01-08-versioning-and-go.html#directory-based-versioning">Directory-Based Versioning</a></li>
<li><a href="u01-08-versioning-and-go.html#branch-based-versioning">Branch-Based Versioning</a></li>
<li><a href="u01-08-versioning-and-go.html#branch-based-with-rolling-main-branch">Branch-Based With Rolling Main Branch</a></li>
<li><a href="u01-08-versioning-and-go.html#summary">Summary</a></li>
</ul>
</li>
<li><a href="u01-08-versioning-and-go.html#implementing-versioning">Implementing Versioning</a>
<ul>
<li><a href="u01-08-versioning-and-go.html#overview">Overview</a></li>
<li><a href="u01-08-versioning-and-go.html#initial-migration-to-versioning">Initial Migration to Versioning</a></li>
<li><a href="u01-08-versioning-and-go.html#changes-within-one-major-version">Changes Within One Major Version</a></li>
<li><a href="u01-08-versioning-and-go.html#introducing-a-new-major-version">Introducing a New Major Version</a></li>
<li><a href="u01-08-versioning-and-go.html#notes-on-automation">Notes on Automation</a></li>
</ul>
</li>
<li><a href="u01-08-versioning-and-go.html#conclusion">Conclusion</a></li>
</ul>
<h3 id="notes-on-terminology"><a class="header" href="#notes-on-terminology">Notes on Terminology</a></h3>
<p>This section clarifies the terminology used further around branches in Git and GitHub. This is important because with the introduction of Go Modules, depending on the approach that is taken to versioning, the meaning of branches may change.</p>
<p>When working with Git, and especially with GitHub and the likes, there are two special kinds of branches:</p>
<ul>
<li>the main branch that is considered as the most recent/stable branch</li>
<li>the default branch that is:
<ul>
<li>the default branch in Git</li>
<li>the default base branch for new pull requests</li>
<li>the default branch shown when the repository is visited on the web</li>
<li>in Git, versions prior to <code>v2.28.0</code> defaulted to <code>master</code>. Starting from <code>v2.28.0</code> it allows specifying an alternative name</li>
<li>on GitHub, before October 1, 2020 it was <code>master</code>. Starting from the day it's <code>main</code>.</li>
</ul>
</li>
</ul>
<p>Knowing this two terms is important, as well as understanding the role and meaning for the workflow.</p>
<h4 id="the-main-branch"><a class="header" href="#the-main-branch">The Main Branch</a></h4>
<p>Historically, and until recently, the main branch has been referred to as <code>master</code>. From this point and further in the book, this branch is referred to as &quot;the main branch&quot;, or simply <code>main</code>.</p>
<p>The main branch in a project usually contains the most recent version of code. Itâ€™s also widely accepted in the open source community that the main branch is the bleeding edge, containing the latest features, thought might not necessarily stable.</p>
<p>The meaning of the main branch in organisations is slightly different. Often, instead of being the cutting edge, the main branch represents the most recent version that is shippable to the customer and/or deployable to production. Of course, if an organisation follows The Git Flow, then the meaning of the main branch is different. We refer to the main branch in a sense that is closest to The GitHub Flow.</p>
<p>It's fair to say that, for the majority of companies, the main branch is the most recent stable branch that is currently in production.</p>
<p>So from now on, when you see &quot;the main branch&quot; or <code>main</code>, and in your case it's still named <code>master</code>, don't be confused.</p>
<h4 id="the-default-branch"><a class="header" href="#the-default-branch">The Default Branch</a></h4>
<p>The default branch in a repository is the one that is:</p>
<ul>
<li>chosen and its contents shown when you visit the projectâ€™s homepage</li>
<li>default base branch for a new pull request.</li>
</ul>
<p>There are a few notes about the default branch. The first is that with GitHub, we've become accustomed to seeing the most recent version of a project when we visit the repository. Very often, the default and main branches in a project are the same branch.</p>
<p>On the other hand, sometimes the default branch is not necessarily the same as the main branch. This becomes especially important the introduction of Go Modules.</p>
<p>Your users, including you, probably like the experience that is familiar. Getting immediate access to the most recent version without needing to switch the branch when you visit a project page on GitHub saves some time and energy, and prevents from unnecessary distractions. So it would be great if it's possible to keep things simple.</p>
<p>As we shall see, Go Modules introduces ways that can disrupt the existing workflows under certain conditions. We will also learn how to keep things in a good order, such that versions are properly and conveniently managed, and users are happy with quick and easy access and to the most recent code.</p>
<h3 id="prerequisites-and-assumptions"><a class="header" href="#prerequisites-and-assumptions">Prerequisites and Assumptions</a></h3>
<p>As we're going to look into some practical aspects of versioning after learning it in theory, it's good to introduce agreements about the environment in which all that works.</p>
<p>For the first, the most important thing here is the version of the programming language. It's worth a reminder that in Go only two most recent versions are officially supported. At the time of writing, the latest stable version is <code>v1.15</code>, and the other is <code>v1.14</code>. Anything else is unsupported, and should not be in use. If you do, then it's strongly advised to perform an update to the most recent version, for many reasons.</p>
<p>So the first agreement, and a prerequisite, is the version of the language. In everything that is related to versioning and Modules, <strong>the book assumes that you use at least version <code>v1.14</code>.</strong></p>
<p>The second important thing is what is used for versioning and dependency management. Although there are alternative opinions and tools, Go Modules is the standard, de facto and de jure. Moreover, it has already proved to be a convenient and handy tool for both, managing dependencies and managing the release cycle of a software project.</p>
<p>So the second agreement and a prerequisite is about versioning, dependencies and tooling. From the first letter to the last, <strong>the book assumes that you use Go Modules for dependency management and versioning in Go projects.</strong></p>
<p>The third agreement is implied by the previous, and is about versioning strategy. In modern times, people increment version numbers in any way they like. This kind of freedom is good to some extent. However, in this work, and this is aligned with the official approach Go takes to versioning, <strong>the <a href="https://semver.org/">Semantic Versioning</a> model is used</strong>. In fact, the way Go manages dependencies with the minimal version selection algorithm is built upon conventions established by Semantic Versioning. Similarly, when and what kind of a change triggers increase in what part of the version, is governed by Semver.</p>
<p>As a quick reminder, Semantic Versioning means that for a version number <code>MAJOR.MINOR.PATCH</code> each part is incremented as follows:</p>
<ul>
<li><code>MAJOR</code> when a breaking change is introduced</li>
<li><code>MINOR</code> when a new feature/update is backwards compatible</li>
<li><code>PATCH</code> when backwards compatible bug fixes are made</li>
<li>also, additional labels for pre-release and build metadata can be added and incremented to the <code>MAJOR.MINOR.PATCH</code> format.</li>
</ul>
<p>Semver has proven to be a meaningful and convenient approach to managing software version. It works perfectly well with a standard, slowly increasing versions model. It also works well for one approach that has become quite popular in recent years. You, of course, have seen versions like <code>v2020.08.12</code>, which can be generalised as <code>YEAR.MONTH.DAY</code> or <code>YEAR.RELEASE_IN_THE_YEAR.FIX</code>. It's less flexible as compared to the classic model, but still fits nicely into the semantic model.</p>
<p>Let's quickly recap the prerequisites:</p>
<ul>
<li>Go version is at least <code>v1.14</code></li>
<li>Go Modules for dependency management and versioning</li>
<li>Semantic Versioning is used to decide when and what version is incremented.</li>
</ul>
<h3 id="approaches-to-versioning"><a class="header" href="#approaches-to-versioning">Approaches to Versioning</a></h3>
<p>With modules, there are three main strategies for versioning a project. The official <a href="https://github.com/golang/go/wiki/Modules">Go Wiki provides</a> some guidelines on how and when to use which. In this section we review what the options are, how each works, and when to use it.</p>
<p>Building a firm understanding of how all this works and how it is represented, is required for working with modules efficiently. For this purpose, there is a quick review of important technical aspects of Modules.</p>
<p>After the review, we consider three approaches to versioning a Go project, namely:</p>
<ul>
<li>Directory-Based Versioning</li>
<li>Branch-Based With Changing Default Branch</li>
<li>Branch-Based With Rolling Main Branch.</li>
</ul>
<h4 id="review"><a class="header" href="#review">Review</a></h4>
<p>Getting familiar with the terminology of Modules is helpful in becoming confident when working with it. The bare minimum includes understanding that:</p>
<ul>
<li>anything that has not been tagged yet, is implicitly considered as <code>v0.0.0-YYYYMMDDHHmmSS-first12SymbolsOfCommitHash</code>
<ul>
<li>e.g. <code>v0.0.0-20190827140505-75bee3e2ccb6</code></li>
</ul>
</li>
<li>anything that has been tagged with <code>v2</code>+ but <strong>is not a module</strong> (i.e. just a tagged release), is implicitly considered as <code>vX.Y.Z+incompatible</code>
<ul>
<li>e.g. <code>v2.2.1+incompatible</code></li>
</ul>
</li>
<li>a correct major version must be set in the <code>go.mod</code> file for versioning to work for versions starting from <code>v2</code>
<ul>
<li>e.g. <code>module github.com/awslabs/goformation/v4</code></li>
</ul>
</li>
<li>each major version requires its own <code>go.mod</code> file (follows directly from the previous point)</li>
<li>an appropriate and valid tag is a must for versioning to work properly</li>
<li>the previous major version must exist in order for the next to work properly on the client
<ul>
<li>i.e. a client fails to use <code>v2.0.0</code> if there is no a single release tagged with <code>v1.y.z</code></li>
</ul>
</li>
<li>backwards compatibility and introduction of breaking changes is governed by <strong>the conventions set by Semantic Versioning</strong>. I.e.:
<ul>
<li>only fixes to stability/correctness/security are allowed in a patch-level release <code>vx.y.Z</code></li>
<li>new features that donâ€™t break backwards compatibility are allowed in a minor-level release <code>vx.Y.x</code></li>
<li>breaking changes are <strong>only</strong> allowed in a major-version release <code>vX.y.z</code></li>
</ul>
</li>
<li>unless a version is given explicitly, with <code>go get</code>/<code>go get -u</code> <strong>updates are performed only within the same major version</strong>, i.e. up to the latest available <code>MINOR</code> version.</li>
<li><code>go get github.com/someorg/somepkg</code> updates the package to its latest version</li>
<li><code>go get -u github.com/someorg/somepkg</code> updates the package <strong>and all its dependencies</strong> to their latest versions, and this is where the Minimal Version Selection algorithm works.</li>
</ul>
<p>Keeping these in mind and following the rules is crucial for versioning to:</p>
<ul>
<li>work</li>
<li>work as expected</li>
<li>work correctly.</li>
</ul>
<p>From now on, the assumption is made that the reader has familiarised themselves with the basics and theory of Modules.</p>
<h4 id="directory-based-versioning"><a class="header" href="#directory-based-versioning">Directory-Based Versioning</a></h4>
<p>The directory-based approach is the most conservative option that is available. New major versions live in the corresponding directories, in the same branch.</p>
<h5 id="what-it-is"><a class="header" href="#what-it-is">What It Is</a></h5>
<p>With this technique, all versions reside in the same branch, but under different, major version-specific top-level directories. When a new major version, <code>vN+1</code> is about to be created, all code from the current version, <code>vN</code> is copied into a new directory, <code>vN+1</code>. Each version is tagged.</p>
<h5 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h5>
<p>The first stable version is kept at the root level of a project. All new major versions are housed in directories that are created in the root directory, named after the version they represent - <code>v2</code>, <code>v3</code>, and so forth.</p>
<p>Essentially, this technique works as follows:</p>
<ul>
<li>everything resides in the main branch</li>
<li>while the project is in active development phase, releases are tagged with <code>v0.y.z</code></li>
<li>when the project reaches maturity, itâ€™s tagged with <code>v1.y.z</code></li>
<li>when there is a breaking change, a new directory <code>v2</code> is created AND:
<ul>
<li>all the code is COPIED over to the new directory</li>
<li>also, the <code>go.mod</code> file</li>
<li>the <code>module</code> statement is changed in the <code>go.mod</code> file to reflect the new version, i.e:
<ul>
<li><code>module github.com/myorg/mylib/v2</code></li>
</ul>
</li>
<li>when needed, a new version is tagged with <code>v2.y.z</code>.</li>
</ul>
</li>
</ul>
<h5 id="when-to-use-it"><a class="header" href="#when-to-use-it">When To Use It</a></h5>
<p>The main benefit of this option is backwards compatibility with pre-Modules versions of Go. In other words, it's recommended for the projects that have backwards compatibility with old versions of Go as one of the main goals.</p>
<p>The Go Team has backported a basic support for Modules to <code>1.9.7+</code> and <code>1.10.3+</code>, and improved support in <code>1.11</code>, so these versions are able to consume modules with versions <code>v2+</code>.</p>
<h5 id="weak-points"><a class="header" href="#weak-points">Weak Points</a></h5>
<p>Although the method is the most conservative and allows for the widest range of supported versions of Go, it has some obvious and hidden downsides.</p>
<p>Firstly, it opens up a possibility for misusing Modules and breaking the client of a library. The major downside of the method is that itâ€™s too tempting to begin sharing code between the versions. If there is a need to share code between versions, pull it off to a separate <strong>module</strong> (i.e. library).</p>
<p>A second downside is pollution of the root directory if the versioning policy is aggressive, and new major versions are released quite often. For example, <a href="https://github.com/go-redis/redis">go-redis/redis</a> has already got <code>v8</code>. If they followed this path (thankfully they don't), they would have ended up with something like below plus all the files they have:</p>
<pre><code class="language-bash">v2
v3
v4
v5
v6
v7
v8
</code></pre>
<p>The only real strong reason for using the major directory approach is backwards compatibility with old, officially unsupported versions of Go. Unless it's a main goal of your project, using this method is not recommended.</p>
<h4 id="branch-based-versioning"><a class="header" href="#branch-based-versioning">Branch-Based Versioning</a></h4>
<p>A more convenient and the intended approach to versioning is based on branches. This approach fully utilises the Go modules functionality that is baked into versions <code>v1.12</code>+ (although <code>v1.11</code> was the first to support modules, itâ€™s was more like a preview).</p>
<h5 id="what-it-is-1"><a class="header" href="#what-it-is-1">What It Is</a></h5>
<p>Each major version is kept in its own branch. When working on patches and minor updates for a version, a working branch is based off of the corresponding home branch for that major version. When a breaking change is introduced, a new major branch is created, and is tagged accordingly.</p>
<h5 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h5>
<p>Before going into detail on how this method works, a couple of things are worth noting:</p>
<ul>
<li>strictly speaking, a new branch is not required, as long as a change can be introduced without breaking the existing code</li>
<li>by default, the Go Team assumes that you use the main branch to house <code>v1.y.z</code>.</li>
</ul>
<p>The way this technique works can be summarised as:</p>
<ul>
<li>everything resides in the main branch</li>
<li>while the project is in active development phase, releases are tagged with <code>v0.y.z</code></li>
<li>when the project reaches maturity, itâ€™s tagged with <code>v1.y.z</code></li>
<li>when a breaking change is about to be introduced, a major new branch <code>v2</code> is created AND:
<ul>
<li>the <code>module</code> statement is changed in the <code>go.mod</code> file to reflect the new version
<ul>
<li>i.e. <code>module github.com/myorg/mylib/v2</code></li>
</ul>
</li>
<li>when needed, a new version is tagged with <code>v2.y.z</code></li>
<li>all changes to <code>v2</code> are targeted towards the <code>v2</code> branch. I.e.:
<ul>
<li>the base branch for any PR that touches <code>v2</code> code is <code>v2</code></li>
<li>effectively, the <code>v2</code> branch is now a second main branch in the project, for anything related to this version</li>
</ul>
</li>
</ul>
</li>
<li>when there is a need to introduce a fix or backport a change to <code>v1</code>, it's done as it was done before:
<ul>
<li>the base branch for any PR that touches <code>v1</code> code is the old main branch (<code>main</code>, <code>master</code> or something else).</li>
</ul>
</li>
</ul>
<h5 id="when-to-use-it-1"><a class="header" href="#when-to-use-it-1">When To Use It</a></h5>
<p>In general, this way is what the Go Team has planned as the intended use of Modules, and what it is designed to work together the best with. It has mostly advantages, including:</p>
<ul>
<li>nice separation of concerns</li>
<li>clear boundaries between incompatible versions</li>
<li>ease of use</li>
<li>ease of automation.</li>
</ul>
<p>However, these guidelines advise against using this method, due to its downsides, which are not as obvious at the first glance, and in favour of the third option.</p>
<p>If, after reading about the rolling main branch technique, that approach does not seem appropriate, then default to this, simple major-branch based way.</p>
<h5 id="weak-points-1"><a class="header" href="#weak-points-1">Weak Points</a></h5>
<p>From a purely technical perspective, this approach has only one, rather minor, downside which is just a new way of working. At the same time, there is a bit bigger question about the changed semantics and perception of the two branch terms introduced in the <a href="u01-08-versioning-and-go.html#notes-on-terminology">Notes on Terminology</a>.</p>
<p>In this context, the following two questions arise:</p>
<ul>
<li>what branch do I use as the main branch?
<ul>
<li>i.e. what is my current, most recent shippable/deployable version, or the branch containing experimental changes?</li>
</ul>
</li>
<li>what branch do I use as the default branch? I.e.:
<ul>
<li>what is the branch to show by default when my repository is visited?</li>
<li>what is the branch new pull requests should use as the base branch?</li>
</ul>
</li>
</ul>
<p>With this technique, the answer to the first question is unclear. By the classic meaning, the bleeding edge should be pointed to the branch that has the highest <code>vX</code>, or to the branch that is even untagged. By the meaning employed by organisations, it should be the branch that is currently deployed in production. Again, it should be the most recent <code>vX</code>. But the community seem to still consider the main branch that is the home for <code>v1</code> as a main branch.</p>
<p>A similar question is about the default branch. Itâ€™s reasonable to say that when you visit the homepage of a project, itâ€™s natural to expect the documentation and code shown to be up to date. Therefore, the default branch for a repository should be changed each time when the major version is incremented, which means a new major branch is created. If the latest version in a project is <code>v3</code>, then the default branch in the repository, for convenience of the users and developers, should be set to this branch.</p>
<p>Besides being technically beneficial, this approach has a philosophical downside - the meaning of the main branch of a repository is changed, and now there is no permanent home for the latest and greatest changes. For other languages, this still holds.</p>
<p>A better option, which has the same technical advantages, but also does not have the methodological downsides of the this one, is a slight modification of major branches and a rolling main branch.</p>
<h4 id="branch-based-with-rolling-main-branch"><a class="header" href="#branch-based-with-rolling-main-branch">Branch-Based With Rolling Main Branch</a></h4>
<p>It would be great to have the questions, left by the previous option above open, answered. It would be also great to keep the meaning of the main branch. As it turns out, there is a way to address all of these.</p>
<p>This approach is an extension to the previously described method, with one, rather significant difference.</p>
<h5 id="what-it-is-2"><a class="header" href="#what-it-is-2">What It Is</a></h5>
<p>In essence, the main branch always represents the most recent version, whatever it is. When a new major version, <code>vN</code>, is introduced, the previous major version, <code>vN-1</code>, is kept in the appropriate major branch, <code>vN-1</code>, for <code>N &gt;= 2</code>. All new development continues going in to the main branch. Hence, everything remains as it should be, in a good order.</p>
<h5 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h5>
<p>A project starts with the main branch and no versions. At some point, the first version is tagged in the main branch, and it remains here. When itâ€™s time to work on a new major version, prior to making any breaking changes, a stable version-specific branch is created, <code>v1</code>. This branch is then used for all subsequent minor and patch releases, they are based off and merged into this branch, when making changes to <code>v1</code> code. As of this point, the main branch is the home for the new version, and is tagged as minor and patch releases are prepared. When itâ€™s time to release another major version, the process is repeated, keeping a snapshot of the current stable version in v2`.</p>
<p>This approach ensures the following:</p>
<ul>
<li>the main branch remains the most recent and stable version (as you merge only code that is proved working)</li>
<li>the main branch continues to be the source of truth</li>
<li>the default branch and the main branch are the same.</li>
</ul>
<p>This is how it works:</p>
<ul>
<li>everything resides in the main branch</li>
<li>while the project is in active development phase, releases are tagged with <code>v0.y.z</code></li>
<li>when the project reaches maturity, itâ€™s tagged with <code>v1.y.z</code></li>
<li>right before working on a breaking change, create a snapshot of the stable code in <code>v1</code>
<ul>
<li>and continue using it for updates and fixes to this version</li>
</ul>
</li>
<li>a new, potentially, incompatible, next version is now located in the main branch, AND
<ul>
<li>the <code>module</code> statement is changed in the <code>go.mod</code> file to reflect the new version, i.e <code>module github.com/myorg/mylib/v2</code></li>
<li>when needed, a new version is tagged with <code>v2.y.z</code></li>
</ul>
</li>
<li>when it's time for the new version, right before working on a breaking change, create a snapshot of the stable code in <code>v2</code>
<ul>
<li>and continue using it for updates and fixes to this version</li>
</ul>
</li>
<li>a new and, potentially, incompatible, next version is now housed in the main branch, AND
<ul>
<li>the <code>module</code> statement is changed in the <code>go.mod</code> file to reflect the new version, i.e <code>module github.com/myorg/mylib/v3</code></li>
<li>when needed, a new version is tagged with <code>v3.y.z</code></li>
</ul>
</li>
<li>repeat.</li>
</ul>
<p>This model allows an easy to understand, simple to work with and clean solution. The questions about the meaning and roles of the main and default branches are answered.</p>
<h5 id="when-to-use-it-2"><a class="header" href="#when-to-use-it-2">When To Use It</a></h5>
<p>The guideline is to prefer this method whenever possible and <strong>by default</strong>. Only use the alternatives when (not if) there is no way this approach can work.</p>
<h5 id="weak-points-2"><a class="header" href="#weak-points-2">Weak Points</a></h5>
<p>As this technique is an extension of the major-branch approach, and it has addressed the weak points left since, it's hard to find a reasonable downside.</p>
<p>Of course, someone could argue that:</p>
<ul>
<li>it does not support the pre-Modules versions of Go</li>
<li>there is some added process into when to do what.</li>
</ul>
<p>However, the reality is such that:</p>
<ul>
<li>when you need support for old versions, use <a href="u01-08-versioning-and-go.html#directory-based-versioning">the major version directory</a> technique</li>
<li>without a process, there is no order.</li>
</ul>
<h4 id="summary"><a class="header" href="#summary">Summary</a></h4>
<p>As we saw, for a new project, it's important to make a right decision at the beginning, as it significantly simplifies things going forward. Nonetheless, even changing the approach for an existing project from one to another is surely doable, it just requires a little more effort. What is important, however, that the method used for versioning, is convenient, and is not limiting when looking into the future. Pro-actively preventing from accumulating legacy, or actively working on reducing the amount if it exists, is always worth the effort.</p>
<p>The following table combines together the facts that are likely to be involved when deciding on the approach to versioning.</p>
<table><thead><tr><th>Name</th><th>How</th><th>Next</th><th>Default</th><th>Main</th><th>Go</th><th>When</th></tr></thead><tbody>
<tr><td>Major Directory</td><td>dir<br><code>vN</code></td><td>dir<br><code>vN+1</code></td><td><code>main</code></td><td><code>main</code></td><td><code>v1.9.7+</code><br> <code>v1.10.3+</code><br><code>v1.11+</code></td><td>Support for old versions</td></tr>
<tr><td>Major Branch<br><code>v1</code> in <code>main</code></td><td>branch<br><code>vN</code></td><td>branch<br><code>vN+1</code></td><td>latest <code>vN</code></td><td>latest <code>vN</code></td><td><code>v1.11+</code></td><td>When the major branch with rolling <code>main</code> does not suit</td></tr>
<tr><td>Major Branch<br>rolling <code>main</code></td><td>branch<br><code>vN-1</code></td><td><code>main</code></td><td><code>main</code></td><td><code>main</code></td><td><code>v1.12+</code></td><td>By default, the preferred choice</td></tr>
</tbody></table>
<p>So choose wisely, experiment, implement and move on. In general, stick to the third option. :-)</p>
<h3 id="implementing-versioning"><a class="header" href="#implementing-versioning">Implementing Versioning</a></h3>
<p>Having reviewed the theory in the preceding sections, let's now turn to the practical side of the subject. Specifically, there are three basic questions about versioning:</p>
<ul>
<li>What does the initial migration to versioning look like for a stable project?</li>
<li>What does the process look like within the same major version?</li>
<li>What does the process look like when a new major version is introduced, assuming versioning has already been implemented?</li>
</ul>
<p>This list is, of course, not exhaustive, and barely scratches the surface of all possible cases. For more information, see <a href="https://github.com/golang/go/wiki/Modules">the Modules page</a> on the official Go Wiki. This section aims to provide the reader with guidelines on how to achieve versioning. If a situation you're in is more of an edge case, and is not described here, then it's likely to be covered by the Go Team.</p>
<h4 id="overview"><a class="header" href="#overview">Overview</a></h4>
<p>One last pre-flight check before moving on to the practical advice. The procedures and steps described further rely on certain assumptions, and will not work if some preconditions aren't met. Here we briefly remind what those conditions are.</p>
<p>The following is considered as a given, and further is implied to be true:</p>
<ul>
<li>Semantic Versioning is used, and strictly followed</li>
<li>Go Modules is the default
<ul>
<li>any library/project that has not been migrated to Modules yet, should be migrated before proceeding</li>
</ul>
</li>
<li>No backwards compatibility with pre-Modules versions of Go, including:
<ul>
<li>1.9.7+</li>
<li>1.10.3+</li>
<li>sometimes, 1.11</li>
</ul>
</li>
<li>No backwards compatibility with projects/libraries those dependencies are managed with <code>dep</code> or anything else but Modules.</li>
</ul>
<p>With this in mind, letâ€™s move on to concrete steps towards versioning.</p>
<h4 id="initial-migration-to-versioning"><a class="header" href="#initial-migration-to-versioning">Initial Migration to Versioning</a></h4>
<p>Initial migration to versioning may be required in several cases. For example, a library might have been already stable for a while, but has not been versioned yet. This is quite often the case for libraries developed by companies and used internally. The same may as well apply to an open-source package.</p>
<p>You may also want to perform the initial transition to the Go way of versioning even if your project already uses versions in its simplest form, i.e. just tags.</p>
<p>The steps below assume the first case. However, the procedure will also work for the second scenario, with the only difference being the starting point. The instructions assume that the current state of a library is stable, and the intent is to migrate and version it properly, <em>without breaking potential clients that might the project</em>. So it's cautious and has steps that are aimed at providing the strongest guarantee.</p>
<p>This is how the initial migration may look like for a previously non-versioned project to versioning:</p>
<ul>
<li>pull the most recent version of the main branch</li>
<li>create a tag <code>v0.1.0</code> in the main branch</li>
<li>push the tag
<ul>
<li>at this point, all clients that have a pseudo-version <code>v0.0.0-etc</code> will be able to get this version (if don't use vendoring and are running <code>go get</code>, <code>go build</code> or any command that implies downloading modules)</li>
<li><em>if migrating a project that already uses tags, then increment the <code>MINOR</code> version</em></li>
</ul>
</li>
<li>optionally, update clients explicitly, if needed, but this is superficial, due to the point above
<ul>
<li>at this point, we have to fix the first stable version, as there is no such a version as <code>v0</code>, hence there is no way yet to introduce a breaking change, as we need to landmark the stable version</li>
</ul>
</li>
<li>create a new branch off of the main branch, <code>v1</code></li>
<li>checkout to <code>v1</code></li>
<li>push the branch to GitHub
<ul>
<li>from now on, this is the new home for all further changes related to the initial version</li>
<li>mark the branch as <code>protected</code> to avoid deleting it by accident</li>
</ul>
</li>
<li>create a <code>v1.0.0</code> in the main branch</li>
<li>push the tag
<ul>
<li>at this point, clients that previously had a pseudo-version <code>v0.0.0-etc</code> and used autoupdates, were migrated to <code>v0.1.0</code>, and continue using it</li>
<li>clients that havenâ€™t attempted updating, or use vendoring, remain on a pseudo-version <code>v0.0.0-etc</code>, and will continue using it</li>
<li>even if someone updates a client, as the <code>v1.0.0</code> points to the same stable code, so nothing breaks</li>
</ul>
</li>
<li>optionally, update clients explicitly, if needed
<ul>
<li>at this point, any client that has been migrated to <code>v1.0.0</code>, will not start using any other major version unless explicitly told to do so using <code>go get</code> with an explicit tag or <code>latest</code>, and import of the versioned module</li>
</ul>
</li>
<li>checkout out back to the main branch</li>
<li>branch off of the main branch to make a change to the <code>go.mod</code> file</li>
<li>increment the version of the module in <code>go.mod</code>, i.e.:
<ul>
<li><code>module github.com/myorg/mylib/v2</code></li>
</ul>
</li>
<li>commit, push</li>
<li>open a PR targeted to the main branch</li>
<li>pass review, merge the PR</li>
<li>pull the updated main branch</li>
<li>create a tag with the incremented major version, <code>v2.0.0</code></li>
<li>push the tag
<ul>
<li>donâ€™t worry about clients. Unless explicitly updated, they remain on the previous stable version, <code>v1.y.z</code></li>
</ul>
</li>
<li>from now on, youâ€™re free to make any breaking changes</li>
<li>from now on, follow the processes described in sections below:
<ul>
<li>when need to make a minor or patch change, see <a href="u01-08-versioning-and-go.html#changes-within-one-major-version">Changes Within One Major Version</a></li>
<li>when need to create a new major version, see <a href="u01-08-versioning-and-go.html#introducing-a-new-major-version">Introducing a New Major Version</a></li>
</ul>
</li>
<li>celebrate success.</li>
</ul>
<p>Although this process may seem a bit complicated, it's rather not, and is required only once for a module. By doing this way we can be sure the users of a package won't be accidentally affected.</p>
<h4 id="changes-within-one-major-version"><a class="header" href="#changes-within-one-major-version">Changes Within One Major Version</a></h4>
<p>Assuming that the initial transition has been done, making a new <code>MINOR</code>- or <code>PATCH</code>-level release within the same major version is straightforward. On average, it looks like this:</p>
<ul>
<li>branch off of the major versionâ€™s home branch</li>
<li>make changes</li>
<li>commit, push, repeat</li>
<li>open a PR targeted at the major versionâ€™s home branch, pass review, merge the PR</li>
<li>pull the updated major version branch</li>
<li>depending on the level of change (<code>MINOR</code> or <code>PATCH</code>), figure out the last version for that level</li>
<li>create a tag with the incremented version for the level</li>
<li>push the tag.</li>
</ul>
<h4 id="introducing-a-new-major-version"><a class="header" href="#introducing-a-new-major-version">Introducing a New Major Version</a></h4>
<p>Introducing a new major version involves a little more steps as compared to minor/patch. However, on average, this should probably happen not too often, a couple of times a year. The frequency of this procedure depends on the aggressiveness of the release cycle.</p>
<p>So, <strong>assuming that the project has already used another major version before</strong>, this is is what it looks like:</p>
<ul>
<li>suppose the current version is <code>v2</code>, and a new major version, <code>v3</code>, should be introduced</li>
<li>before any changes, create a branch named after <strong>the current major version</strong>, based off of the most recent version of <code>main</code>
<ul>
<li>in this case, it's <code>v2</code></li>
</ul>
</li>
<li>push the branch to GitHub (or the service you use, obviously)
<ul>
<li>additionally, if the functionality of the service allows so, mark the branch as <code>protected</code> to guard against an accidental force-push or removal, as this branch is, from this moment, essentially, the home for the previous major version for as long as that version will be maintained</li>
</ul>
</li>
<li>figure out the last minor version for this major version, <code>v2</code>
<ul>
<li>let's suppose it's <code>v2.3.0</code></li>
</ul>
</li>
<li>from the new home branch of this version, the <code>v2</code> branch, create a new tag with the incremented minor version
<ul>
<li>in this case, it's <code>v2.4.0</code></li>
</ul>
</li>
<li>push the tag</li>
<li>branch off of the <code>main</code> branch to make a change to the <code>go.mod</code> file
<ul>
<li>this should be a regular, short-lived development branch</li>
</ul>
</li>
<li>increment the version of the module in <code>go.mod</code>
<ul>
<li>i.e. <code>module github.com/myorg/mylib/v3</code></li>
</ul>
</li>
<li>commit, push</li>
<li>open a PR targeted at the main branch</li>
<li>pass review, merge the PR</li>
<li>pull the updated main branch</li>
<li>create a tag with the incremented major version, <code>v3.0.0</code></li>
<li>push the tag</li>
<li>make coffee.</li>
</ul>
<h3 id="notes-on-automation"><a class="header" href="#notes-on-automation">Notes on Automation</a></h3>
<p>For a developer, thinking of automating a repeatable, prone to human errors, or just boring process is natural.</p>
<p>However, to better understand the process, it's worth practicing it to a point when you know what the steps are, what <em>exactly</em> they do, and why a certain step is needed. Only after having practiced it enough, when you fully understand the task, attempt automating it. Learning the process by hand gives a sense of what is going on, and helps in understanding of what to do if something goes wrong, or if it does not work as expected. Automation based on a solid experience is more likely to be solid and robust. Try doing this earlier, and the flaws in your knowledge leak into the implementation, making it flawed too, in some way or the other. <strong>This is a general principle of automation</strong>:</p>
<blockquote>
<p>Whenever the legal moves of a formal system are fully determined by algorithms, then that system can be automated.</p>
<p>â€“ John Haugeland, Artificial Intelligence: The very idea (1985)</p>
</blockquote>
<p>In the context of versioning, there are some steps that can potentially be automated, although not all of them seem to require it. For example, the initial transition to Modules highly depends on each particular project. Attempts to generalise it would require making lots of assumptions and guesses about the state of a project before conventing it into a module. As this process is required only once <del>in a blue Moon</del> per project, there is little to zero value in automating it beyond what the Go toolset already offers.</p>
<p>Potentially, the task of introducing a new major version might be a good candidate for future automation. The procedure described in the corresponding section is straightforward, and comes down to:</p>
<ul>
<li>determining the current <code>MAJOR</code> version, <code>vN</code></li>
<li>creating a major version branch for keeping the state of this version, <code>vN</code></li>
<li>pushing the branch</li>
<li>determining the current <code>MINOR</code> version, <code>vN.M.P</code></li>
<li>switching to the branch</li>
<li>tagging it with the next <code>MINOR</code> version, <code>vN.M+1.0</code></li>
<li>pushing the tag</li>
<li>switching back to the main branch</li>
<li>branching off of it</li>
<li>increasing the <code>MAJOR</code> version number in the <code>go.mod</code> file, <code>vN+1</code></li>
<li>pushing, merging, pulling the main branch again</li>
<li>tagging it with the incremented version, <code>vN+1.0.0</code></li>
<li>pushing the tag.</li>
</ul>
<p>On the other hand, creating a new major version is an important process, a significant step in the release cycle, and it is non-linear by its nature. It might include some extra steps requiring human interaction, approvals, or anything else. As long as a tool is able to <em>reliably</em> do the work, and <em>properly</em> handle <em>potential</em> failures, it might be useful. Otherwise, the world is already full of sub-optimal and poor programs, and it won't benefit from one more piece of software, &quot;hacked&quot; over night.</p>
<p>Another part that can be automated is introduction of a new <code>MINOR</code> or <code>PATCH</code> release within the same <code>MAJOR</code> version. This process is mostly the same as with other languages, with the only difference being that if an update is being introduced to a major version that is not the current major version, a tool must take into account that a new tag must should be created from the corresponding major branch.</p>
<p>Some steps can definitely be automated though. We first need to seek for the most likely sources of errors. An obvious candidate, and the most boring thing to do, is figuring out the previous version tag and creating a new tag with a proper version. It's a simplest step, but its simplicity is deceiving, as messing it up once could cause issues to the users of a project. That's why having a command that shows the current and next versions would be helpful.</p>
<p>Stick to the KISS principle and UNIX philosophy. There is a set of powerful tools which are available at our disposal, without the need to reinvent the wheel. Some of these include:</p>
<ul>
<li><code>make</code></li>
<li><code>git</code></li>
<li><code>awk</code></li>
<li><code>sed</code>.</li>
</ul>
<p>With some thought and testing, a library can be provided with a minimal set of <code>PHONY</code> targets in the <code>Makefile</code> that simplifies calculation of a version number. For instance:</p>
<ul>
<li><code>make next-minor</code>
<ul>
<li>returns the next minor version for the current version (based on the branch, existing tags and <code>go.mod</code>)</li>
</ul>
</li>
<li>similarly, <code>make next-patch</code></li>
<li><code>make release-minor</code>
<ul>
<li>in addition to properly calculating a version, it creates and pushes a tag</li>
</ul>
</li>
<li>similarly, make <code>release-patch</code>.</li>
</ul>
<p>Even such a minimal set of tools is enough to simplify everyday (in reality, weekly) maintenance of a library to not worry about the process much, if at all.</p>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>This section has shown that choosing and implementing a good approach to versioning is important for the lifecycle of a project, regardless of its size.</p>
<p>A versioning strategy has effect at various levels, ranging from what branch developers start off and merge into everyday, all the way up to what end users of the software see by default when they're visiting the homepage of the project's repository. A good strategy, as all good things, reduces the mental load and saves time, whereas a poor strategy confuses and requires extra steps to get something which should be accessed easily.</p>
<p>A good strategy also works both short- and long-term. In short-term, it allows for simple and straightforward introduction of a new major version. Long-term, it allows maintaining multiple major versions easily for as long as you should as a responsible developer. A good approach is also universal, as it does not depend much on a particular technology.</p>
<p>The third option given here, the Major Version Branch with Rolling Main Branch, looks like a candidate for a good one. It does not actually depend on anything specific to Go. It works for other technologies as well as it does with Go. It's good short- and long-term, and it does keep the conventions that the community is accustomed to, along with keeping the meaning of the main and default branches. It addresses the needs of versioning without raising new issues. This is a good sign.</p>
<h2 id="notes-on-release-notes"><a class="header" href="#notes-on-release-notes">Notes on Release Notes</a></h2>
<p>One more thing to talk about before wrapping up the project layout guidelines, and a follow up for the previous topic, is release notes. We will briefly discuss some ideas for better communicating what's changed in a project.</p>
<p>This is important for both, internal and external audiences. For a private project in an organisation, the internal audience is developers who use the software; the external audience is management and other potentially interested parties. When done well, and everyone knows where to look at, release notes that are published regularly and reflect the work that has been done, serve as a summary and description of the outcomes.</p>
<p>In an open-source project, the internal audience is committers and maintainers; the external audience is users of the project. For the internal audience, often working from all over the world, this helps with keeping everyone in sync with what is going on in the project. For the users, it's the only convenient way for knowing about changes, and it provides information required for planning and deciding on when, and often - how, to perform an update. Of course, in both cases, private and public projects, audiences may, and often do, overlap.</p>
<p>Although the reasoning above just touches on the topic, this is already sufficient to understand the importance of preparing and publishing some form of release notes. This should be done for each and every release. Needless to say that a <code>MAJOR</code> version <em>must</em> come with a comprehensive description of the changes it contains.</p>
<p>The main guideline of this section is summarised as <strong>provide your project with a changelog</strong>, informing the users of the software about the changes you've made. A few practices help in achieving this:</p>
<ul>
<li>being generally disciplined, in the process, keeping things in a good order</li>
<li>writing good commit messages</li>
<li>using annotated tags</li>
<li>and sticking to good practices of maintaining a changelog.</li>
</ul>
<p>A changelog is not release notes though. A changelog is more on the technical side of a project, while release notes are more on the product, or even marketing side. For software projects whose target audience is developers, the terms may be interchangeable, but not necessarily are.</p>
<p>As this book is more about the technical side of things, we're focusing on maintaining a good changelog, and related activities. Let's look at these a bit closer.</p>
<h3 id="write-good-commit-messages"><a class="header" href="#write-good-commit-messages">Write Good Commit Messages</a></h3>
<p>Perhaps there are not so many topics in software development with such a long history of attempts to establish good practices, and make everyone in a team to follow them, as writing good commit messages.</p>
<p>One of the famous and best resources that summarises what needs to be said about writing commit messages, is <a href="https://chris.beams.io/posts/git-commit/">this article</a>. If you haven't seen and read it yet, stop reading this, and don't get back until that article is fully read.</p>
<p>A quick summary on how to do better with commit messages:</p>
<ol>
<li><a href="https://chris.beams.io/posts/git-commit/#separate">Separate subject from the body with a blank line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#limit-50">Limit the subject line to 50 characters</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#capitalize">Capitalise the subject line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#end">Do not end the subject line with a period</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#imperative">Use the imperative mood in the subject line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#wrap-72">Wrap the body at 72 characters</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#why-not-how">Use the body to explain what and why vs. how</a>.</li>
</ol>
<p>This is important for many reasons, such as overall order, clean history, transparency and the ease of working with the commit tree. Good commit messages become even more important as it reduces the effort required to gather the list of changes for the changelog.</p>
<h3 id="use-annotated-tags"><a class="header" href="#use-annotated-tags">Use Annotated Tags</a></h3>
<p>By default, create annotated Git tags.</p>
<p>As you know, Git offers two flavours of tags - lightweight and annotated. A lightweight tag is a pointer to a specific commit. An annotated tag, on the other hand, is a full Git object, which means it contains the following information:</p>
<ul>
<li>the checksum</li>
<li>who has made the tag, when, and their email</li>
<li>a tagging message (pretty much a commit message, hence same rules apply)</li>
<li>can be signed with GPG (therefore, verified).</li>
</ul>
<p>The official <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git documentation recommends</a> using annotated tags.</p>
<p>Since each tag carries all identity information with it, this helps in figuring out what was changed, when, where and by whom. Combined with good commit messages, annotated tags provide enough information for preparing the list of changes for the changelog. The worst case scenario would be when in order to create a changelog, the information contained in the repository was not enough, and you had to use multiple sources, including the task tracker.</p>
<p>By writing good commit messages and using annotated tags, you have helped your future self with preparing for writing a good changelog.</p>
<h3 id="maintain-the-changelog"><a class="header" href="#maintain-the-changelog">Maintain the Changelog</a></h3>
<p>To keep the audience of a project informed about changes, <strong>maintain the changelog</strong>.</p>
<p>What makes a good changelog? What is important, and requires a special attention? Consider the following suggestions:</p>
<ul>
<li>remember that the changelog is for people</li>
<li>add an entry for each version</li>
<li>keep records in the descending order, i.e. the latest version comes first</li>
<li>always include the date of a release</li>
<li>group changes by their type</li>
<li>be consistent with the style and wording</li>
<li>provide only relevant information.</li>
</ul>
<p>The sub-sections below go into more detail on these suggestions.</p>
<h4 id="changelog-is-for-people"><a class="header" href="#changelog-is-for-people">Changelog is for People</a></h4>
<p>First and foremost, <strong>changelogs are</strong> written to be <strong>read by humans</strong>, not machines. Ultimately, the changelog should answer the question: <strong>will my software work if I update this dependency</strong>, or <strong>does the update break anything</strong>?</p>
<p>Having developed and maintained software that was relied upon in everyday work by developers, both internal and external, itâ€™s safe to say that you either only provide good and valuable changelog and/or release notes, or nothing at all. Something in the middle, an automated non-sense or irrelevant information are just noise that no one is interested in.</p>
<p>The changelog is where engineers look at while making decisions about using a library or updating it. Keep in mind that &quot;engineers&quot; means not only software developers that use the project in their environments; the target audience, depending on the popularity and how widespread the project is, also includes:</p>
<ul>
<li>system administrators and operations engineers</li>
<li>SRE and Devops people</li>
<li>application security analytics and engineers</li>
<li>and whoever is working with them, such as support and sale teams, lead engineers, product managers, designers, etc.</li>
</ul>
<p>Given this, make sure that the changelog provides what it is expected to provide  - the information about what's changed, when, how it affects the user, and what to pay a special attention to.</p>
<h4 id="log-each-version"><a class="header" href="#log-each-version">Log Each Version</a></h4>
<p>Add each version to the changelog.</p>
<p>Although this is self-evident, and does not require further explanation, it's worth reminding that the user should be able to see what has been changed in each particular version of the software. If the software is a library, especially a public one, and is used by other developers in their products, this is a must.</p>
<h4 id="last-version-comes-first"><a class="header" href="#last-version-comes-first">Last Version Comes First</a></h4>
<p>Always add the latest version at the top of the changelog. In other words, it's similar to a stack data structure, versions in the changelog are listed in a reverse order.</p>
<p>This is important for a few reasons:</p>
<ul>
<li>For the first, the information of interest should be accessible as quickly and easily as possible.</li>
<li>Secondly, in most cases, the user is interested in recent changes rather than in earlier versions of the software.</li>
<li>And finally, this helps in saving a tiny but important bit of mental energy, as neither the user, nor a maintainer, has to scroll the entire list to get to the point when reading or updating the changelog.</li>
</ul>
<h4 id="show-the-date-of-release"><a class="header" href="#show-the-date-of-release">Show The Date of Release</a></h4>
<p>Provide each version with the date of release. Use the ISO-8601 format, aka <code>YYYY-MM-DD</code>.</p>
<p>This is essential for keeping track of changes, and it's hard to tell what's more important - the version number, or the date when it was released. Without either, the information is not complete. The date of release establishes a concrete point in the timeline, and allows for relating to a particular version, and correlating between the date and various events.</p>
<p>The format requirement helps to avoid confusions caused by the variety of regional formats. The ISO-8601 format is well-known, simple and easy to understand. Just stick to it.</p>
<h4 id="group-changes-by-type"><a class="header" href="#group-changes-by-type">Group Changes by Type</a></h4>
<p>To simplify reading of a changelog, group changes by the type of a change. This is helpful because structured and organised information is easier to understand, as well as to notice something important.</p>
<p>Some of the most common groups, along with the corresponding types of changes, and the relation to Semantic Versioning, are shown in the table below. For Semver, where multiple options are available, they are given in the order of preference. The table shows an approximate relation, just to visualise how types of changes and version numbers correspond.</p>
<table><thead><tr><th>Group</th><th>Type of a Change</th><th>Semver</th></tr></thead><tbody>
<tr><td>Added</td><td>New Features</td><td><code>MAJOR</code>, or <code>MINOR</code></td></tr>
<tr><td>Changed</td><td>Improvements</td><td><code>MINOR</code>, or <code>MAJOR</code></td></tr>
<tr><td>Fixed</td><td>Bug Fixes</td><td><code>PATCH</code>, or <code>MINOR</code></td></tr>
<tr><td>Security</td><td>Vulnerability Fixes</td><td><code>MINOR</code></td></tr>
<tr><td>Deprecated</td><td>Deprecations</td><td><code>MINOR</code></td></tr>
<tr><td>Removed</td><td>Removed Features/APIs</td><td><code>MINOR</code>, or <code>MAJOR</code></td></tr>
</tbody></table>
<p>For most use cases, these groups should be enough.</p>
<p>However, a project may support multiple platforms (i.e. operating systems and processor architectures, more on this in Unit 2). In addition to changes common across all supported platforms, something different can be added/updated/fixed for a particular architecture. In such case, two options are available:</p>
<ul>
<li>prefix a change that is specific to a particular platform with its name
<ul>
<li>e.g. for an <code>Added</code> change for the Mac</li>
</ul>
</li>
</ul>
<pre><code class="language-text">Added:
    ...
    Mac: Notarisation
    ...
Fixed:
    ...
    Linux: High memory usage when working with large files
    ...
</code></pre>
<ul>
<li>alternatively, group platform-specific changes together, after the list of common changes
<ul>
<li>e.g. for a <code>Fixed</code> change for Linux, a change should be listed in the <code>Fixed</code> sub-list for the <code>Linux</code> list, like</li>
</ul>
</li>
</ul>
<pre><code class="language-text">Common:
- Added
    ...
- Updated
    ...
- Fixed
    ...

Mac:
- Added
    - Notarisation
    ...

Linux:
- Fixed
    - High memory usage when working with large files
    ...
</code></pre>
<p>There are many different ways of grouping, and at some point it might be tempting to add one more category, or a grouping criterion. Resist the temptation, and ask a question &quot;Is this group essential?&quot;. Highly likely it's not, and such a change should belong in one of the existing groups. The importance of this is the subject of the <a href="u01-09-notes-on-release-notes.html#be-consistent">Be Consistent</a> guideline.</p>
<p>A special group of changes, however, makes an exception. A natural part of the project and product development process is upcoming changes that are not going to be included in the next one or a couple of releases. These are usually new features, available for canary testing, and while being developed, they aren't included in a release. If this approach is used in your project, keep these changes at the very top of the changelog, before the latest version. Users and developers would benefit from knowing what's coming, and they would be able to plan accordingly, or become early adopters of new features. As a positive side effect, you can receive feedback sooner.</p>
<h4 id="be-consistent"><a class="header" href="#be-consistent">Be Consistent</a></h4>
<p>Use consistent wording, formatting, and grouping. This is especially important when working in a team of developers. Make sure everyone follows the same visual and writing styles, and the changelog looks nice, and is coherent and consistent. For the reader, it should appear as if it was written by one person.</p>
<p>Specifically, ensure the following:</p>
<ul>
<li>all dates are always in the ISO-8601 format, i.e. <code>YYYY-MM-DD</code></li>
<li>all versions are always in the Semver format, i.e. <code>vX.Y.Z</code></li>
<li>groups are either all Simple Past verbs, or plural nouns from the table <a href="u01-09-notes-on-release-notes.html#group-changes-by-type">given here</a></li>
<li>the list of groups is relatively persistent</li>
<li>changes are articulated and communicated clearly</li>
<li>sections with versions are clickable, for ease of navigation</li>
<li>strive for short and concise descriptions, using, whenever possible, <a href="https://en.wikipedia.org/wiki/Plain_English">Plain English</a>, or the plain version of the language of your choice.</li>
</ul>
<h4 id="provide-relevant-information"><a class="header" href="#provide-relevant-information">Provide Relevant Information</a></h4>
<p>Provide only relevant information that is important for the user or the developer. In other words, keep the signal vs. noise ratio high.</p>
<p>For example, here is what should be included in a changelog, in addition the main contents:</p>
<ul>
<li>changes in the public API</li>
<li>increase/decrease in performance</li>
<li>any implementation-specific changes that may affect the user, especially, in a negative way</li>
<li>updates to dependencies if they contain any of the following:
<ul>
<li>any negative impact on performance</li>
<li>significant increase in the size of the software, aka bloated libraries</li>
<li>significant changes in licensing, including dependencies (yes, you're responsible for this too).</li>
</ul>
</li>
</ul>
<p>Things that are better be left outside of a changelog:</p>
<ul>
<li>internal implementation details that don't affect the user/developer in any way</li>
<li>regular dependency updates</li>
<li>refactoring without a noticeable change in functionality/performance.</li>
</ul>
<p>It's worth noting that sometimes changes are so important that it makes sense to provide a description of the actions required from the user. For non-technical users this is normally communicated through release notes and documentation. For developers, the changelog might be a good place to look at first. However, the home for detailed descriptions, explanations, instruction, migration steps, etc is still documentation. A quick summary and a link to the place in the docs is a good way to start.</p>
<h3 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h3>
<p>What is the most important ingredient in a relationship? Trust. A significant contributor to trust is communication, clear, transparent and honest. As long as involved parties trust each other, the relationships continues to last.</p>
<p>There is a relationship when someone uses software; it's between the user and the developer. The user might be a single person, or a larger group; similarly, there might be a single developer, or an organisation. The important thing is whether there is trust in the relationship.</p>
<p>It is the features and quality of the software what forms the foundation for the trust. If it works, and works well, then users remain loyal. The documentation plays an important role, and is a big part of communication between the developer and user. So far so good.</p>
<p>When is trust lost, assuming there is no betrayal or lie involved? One possible reason is when expectations are not met. The other is, however, when something unexpected happens, regularly, without a notice. When something changes, but neither the changes, nor the reasons for them have been communicated, or communicated poorly.</p>
<p>A changelog is the way for addressing the issue. A well-written changelog communicates what's changed clearly, transparently and honestly. This is why, if you want to build lasting relationships with your users, you need to maintain a changelog.</p>
<p>The ideas and suggestions in this section are based on learnings and experiences gained over many years, and from various sources. A great resource for reference, and where some of the ideas were looked at for inspirations, is <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>. Another good place to learn from is real-life examples. The list below includes some that are worth looking at:</p>
<ul>
<li><a href="https://github.com/hecrj/iced/blob/master/CHANGELOG.md">iced</a></li>
<li><a href="https://github.com/tikv/tikv/blob/master/CHANGELOG.md">tikv</a></li>
<li><a href="https://github.com/linebender/druid/blob/master/CHANGELOG.md">druid</a></li>
<li><a href="https://github.com/meilisearch/MeiliSearch/blob/master/CHANGELOG.md">MeiliSearch</a></li>
<li><a href="https://github.com/docker/docker-ce/blob/master/CHANGELOG.md">docker-ce</a></li>
<li><a href="https://github.com/olivierlacan/keep-a-changelog/blob/master/CHANGELOG.md">keep-a-changelog</a>.</li>
</ul>
<p>The ultimate goal is to let users of your software know about the changes you make. If the suggestions given here don't suit, or too resource demanding, focus on communicating changes to the user in a simplest possible form. While the way it's done is important, it's secondary to the fact that it's done at all. Trust is hard to gain, but easy to loose. Make sure that, while making changes to increase trust, the way the changes are communicated support that increase.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>We began the unit with the excitement of starting something new. However, it's often the case that this excitement fades away quickly, if the project has not been properly cared of.</p>
<p>The guidelines given in this unit are only the very tip of the iceberg of preparing and maintaining a project in a healthy and consistent state. We briefly discussed techniques that apply at the highest, the project level. Project design depends on decisions made at each level. In next units, we go deeper, layer by layer, to learn more about better design choices.</p>
<p>Consistently following the guidelines requires an effort. At times it may seem too much to pay attention to, or too meticulous. However, it pays off in long term, and it always does. One of the best things one can do for their future self is to plan and prepare upfront such that as less as possible changes are required in places which <em>should be</em> set and just work. But that &quot;just work&quot; <strong>is</strong>, in fact, a consequence of these activities which are often invisible when done, and very noticeable when forgotten, ignored, or neglected.</p>
<p>At the end of the unit it is worth summarising all of the suggestions and recommendations given so far, compiled in one list:</p>
<ol>
<li>In general and overall, strive for a good project layout.</li>
<li>For any kind of project:
<ul>
<li>provide files required for the project</li>
<li>keep the number of root elements at minimum</li>
<li>keep any level clean and up to date</li>
<li>don't create artificial hierarchy</li>
<li>group non-code files by their purpose</li>
<li>provide the Makefile</li>
<li>store credentials somewhere else</li>
</ul>
</li>
<li>For a library:
<ul>
<li>provide a good README file</li>
<li>keep the top-level list of objects of a manageable size</li>
<li>provide examples</li>
<li>provide benchmarking information</li>
</ul>
</li>
<li>For a single application:
<ul>
<li>use <code>cmd</code> directory for entry points (<code>main.go</code> files)</li>
<li>use <code>bin</code> directory for binaries</li>
</ul>
</li>
<li>When working with a monolithic repository, bear in mind the following:
<ul>
<li>avoid naively throwing in everything in to one repository</li>
<li>service-based monorepos may work, but they are harder to maintain long-term</li>
<li>similarly, entity-focused repositories are especially prone to dependency cycles</li>
<li>prefer a structured monolithic repository, and ensure that:
<ul>
<li>each package is carefully placed in the tree</li>
<li>utility code is being maintained as own standard library</li>
<li>there is a sandbox for code with breaking changes</li>
</ul>
</li>
<li>when even more flexibility is required/desired, consider:
<ul>
<li>using nested modules within a single monorepo</li>
<li>or even using multiple monolithic repositories
<ul>
<li>some of which are &quot;simple&quot;, single-module monorepos</li>
</ul>
</li>
<li>and finally, there is always the most flexible option with multiple monorepos composed of nested modules</li>
</ul>
</li>
</ul>
</li>
<li>When versioning your Go project, remember of these:
<ul>
<li>the main branch is usually considered to be the source of truth</li>
<li>the default branch should be the same as the source of truth</li>
<li>avoid the directory-based approach to versioning unless you absolutely must</li>
<li>similarly, there are few reasons for using the simple branch-based approach</li>
<li><strong>use</strong> the branch-based approach with rolling main branch</li>
</ul>
</li>
<li>When working on code and then preparing a new version, remember to:
<ul>
<li>write good commit messages</li>
<li>use annotated tags</li>
<li>maintain the changelog, keeping in mind that
<ul>
<li>changelog is for people</li>
<li>there must be a record for each version</li>
<li>last version comes first in the list</li>
<li>each release must include the date it's released</li>
<li>changes should be grouped by the type</li>
<li>the style and wording should be consistent</li>
<li>and the information you add to the changelog is relevant.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>An insightful reader might have already noticed that there is something common among the guidelines proposed here. The underlying principles for the suggestions in this and next units are basic and simple. Everyone knows about them, but fewer people do actually follow them in real life. As a reminder and a hint, they're listed below:</p>
<ul>
<li>Do what needs to be done, and don't be lazy.</li>
<li>Anything you do, do it at the best level.</li>
<li>Especially, when nobody is watching.</li>
<li>Learn and then follow rules.</li>
<li>Always do your homework.</li>
<li>Never stop learning.
<ul>
<li>Regularly update your understanding of the things you already know.</li>
<li>Learn something new.</li>
</ul>
</li>
</ul>
<p>In the next unit, we take a step forward, and introduce guidelines on various aspects of package design in Go.</p>
<h1 id="package-layout"><a class="header" href="#package-layout">Package Layout</a></h1>
<p>Alright, as we now know how to organise a project, it's time to think about next layer in the application design. In Go, applications are built of packages which makes a package an important part of the overall architecture of a project. This unit focuses on guidelines for designing packages well.</p>
<p>A package is one of the core concepts in Go. A piece of code cannot exist outside of a package, so a package is created before anything else. Packages are <strong>the</strong> high-level building blocks for an application. They <em>provide</em> us with different abilities and tools to accomplish a task. Therefore, whether an application is well designed or not depends on how the packages are organised in the first place. As packages are the vital for the ecosystem, it's important to get this part right. A good package layout will be mostly unnoticed, as it feels just right and natural, whereas a poor layout can lead to many potential issues, and is disturbing in many different ways.</p>
<p>The goal of this unit is to provide guidelines on how to work with packages - create, structure, and maintain, including:</p>
<ul>
<li>when and why create a package</li>
<li>what to put in it</li>
<li>how to choose a proper name</li>
<li>how to organise a package</li>
<li>supporting code for multiple platforms.</li>
</ul>
<p>Packages in Go are different from similar concepts in other languages. Since it's a modern language, it approaches code organisation in a unique way that takes into account what has and has not worked well, and introduces some new ideas. As a result, we get a powerful system that makes it easier to use, write and distribute software. Failing to acknowledge the difference from other languages, and to learn thinking about code organisation the Go way, are two of the major contributors to poor application design, issues with dependency management, leaked implementation details, lack of encapsulation and wrong abstractions, and so forth. When a package is designed in a wrong way, expect all sorts of problems.</p>
<p>What we want for out applications is quite an opposite. A coherent architecture, effortless dependency management, meaningful encapsulation, narrow and minimal public API, ease of maintenance, and so on. To get there, we continue with a package. Our next step is getting a good understanding of what it is.</p>
<h2 id="what-is-a-package"><a class="header" href="#what-is-a-package">What is a Package</a></h2>
<p>You may already know that a package in Go is defined as a collection of files in the same directory that are compiled together. A file contains variables, constants, types, and functions, and they're visible in other files within the package. Visibility of a symbol outside of the package is controlled by the first character in the name: a capital letter makes a symbol exported, and a lowercase letter marks it as unexported. A package in Go <strong>provides</strong> a way to accomplish a set of tasks.</p>
<p>While sounding simple, this definition gives us all that we need to lay out the foundation for a good software design. Having thought about what it really means, and how to employ it, you realise that the package paradigm in Go is meant to embrace and support many of the good practices in software engineering. The responsible engineer <em>knowns and applies</em> the <a href="https://en.wikipedia.org/wiki/SOLID">SOLID design principles</a>.</p>
<p>So how does exactly the package system help us with software design? This is what packages help us to do:</p>
<ul>
<li>provide namespace and set the context</li>
<li>group code by responsibilities, roles and functionality, and keep them clear (SRI), i.e. encapsulate what varies</li>
<li>facilitate extension over modification (OCP)</li>
<li>build and maintain proper abstractions (LSR)</li>
<li>keep interfaces and public API narrow (ISP), i.e. hide implementation details and decoupling</li>
<li>maintain healthy dependencies between objects (DIP)</li>
<li>distribute and reuse code (DRY)</li>
<li>keep it simple, testable and atomic (KISS)</li>
<li>and so on.</li>
</ul>
<p>What a Go package is not? The most important thing to remember is that packages are not means of/for implementing a hierarchy. The hierarchy of libraries in Go is <strong>flat</strong>. Bear this fact in mind. Each time when you encounter <code>net/http</code>, it does not mean that <code>http</code> is a descendant of <code>net</code>, or a sub-package. This is done simply as a matter of namespacing and setting the context, and no more than that. The <code>net</code> package is completely independent, and can be used on its own, so the <code>net/http</code> package is (although it does use <code>net</code> internally). In spite of being inside <code>net</code>, there is no hierarchical or inheritance relation between the two. The <code>http</code> package is <em>just</em> located within the <code>net</code> package's folder.</p>
<p>Building a firm understanding of the packages' nature and purpose is one of the keys to designing changeable and maintainable software. Without this understanding, anything you do, even if it <em>seems</em> to be right, will eventually fall apart. It does not matter how well a house is built, if it stands on a weak and shaky foundation.</p>
<p>One of the most often mistakes is creating a package, not knowing when to and when not to do so. On one extreme, a project may have too much code, with too different roles mixed in a single package. On the opposite, a project may abuse the use of packages so that there is way too many of them. Neither of these situations helps in building great software.</p>
<p>You need to find balance, and knowing when it's a good time for creating a package is helpful.</p>
<h2 id="when-to-create-a-package"><a class="header" href="#when-to-create-a-package">When to Create a Package</a></h2>
<p>A package is created to <strong>improve</strong> the design and architecture of software. This is the single and only reason for the existence of a package. What does it mean? The software design principles help understand this.</p>
<p>A package should be created to accomplish one or more of the following goals:</p>
<ul>
<li>encapsulation of varying parts of a project</li>
<li>decoupling and setting boundaries between various parts</li>
<li>implementing abstract and extensible data and processes</li>
<li>providing reusable and reliable functionalities</li>
<li>distributing code.</li>
</ul>
<p>That is all about it. If a package exists, but its existence does not support at least one of the goals above, something is wrong with the design. Here are some reasons to question the package's existence:</p>
<ul>
<li>if a package does not make sense without another package (in a sense that it can't be used on its own)</li>
<li>if a package is located inside another package, and can't be used outside it, and it's not an <code>internal</code> package</li>
<li>if use of a package leads to an import/dependency cycle.</li>
</ul>
<p>When planning a package, the following properties of code should guide the process:</p>
<ul>
<li>roles that objects in it play</li>
<li>responsibilities that the code carries</li>
<li>functionality it provides</li>
<li>behaviours of objects.</li>
</ul>
<p>Having clarified when to create a package, and before we can next steps, it's good to think about the lifecycle of a package, and how its design and contents influence the maintenance process.</p>
<h2 id="keep-public-api-as-narrow-as-possible"><a class="header" href="#keep-public-api-as-narrow-as-possible">Keep Public API as Narrow as Possible</a></h2>
<p>Keep the public API of a package as narrow as possible. Put another way, keep the number of exported objects and elements at a minimum.</p>
<p>To understand why this is important, we need to remember a few things. First, packages in Go are building blocks, and a unit of distribution. A useful library  found on the net is often a single package. A useful piece of software is made of a set of packages. Therefore, the API surface of a project is a superset of APIs of all packages in it. This makes it very important to design each individual package mindfully and consciously.</p>
<p>Second, in the vast majority of cases, it is the behaviour what software provides us with, not the concrete features. In other words, we're more interested in accomplishing a task by making the library do something we need, rather than in what fields are available on the library's objects. A library that exposes only behaviour, or behaviour and a minimum of features, is easier to both, use and maintain. Packages with lots of details exposed to the user tend to increase cognitive load: users are forced to think more than they really need to use the library, and authors have to keep in mind how each change would affect the user.</p>
<p>Third, one characteristic of a great software is that it is impossible or hard to misuse it. In other words, good libraries tend to minimise the risk of error by being designed and implemented in a way that helps to use it correctly. Such libraries also have minimal to no side effects, often secure by default, have and modest resource consumption.</p>
<p>Fourth, the only thing that is constant about software is CHANGE. Change means maintenance, finding and fixing bugs, changing implementation details for good, such as performance or security, adding new features, and more. As people use the software, they become more dependent on it. If a library does something valuable, it may become popular, and this is where things get complicated. The more people use the library, and the longer they do it, the harder it is to introduce changes, and the higher the risk of breaking others' systems. Even a simple update might take a long period of time to introduce, and even longer to be fully adopted by the users.</p>
<p><strong>When writing software, you need to plan and organise it in such a way as to maximise the ability to change as much as you can, as fast as you can.</strong> In the context of package planning and design, this means that you need to keep the number of exported objects and elements at a possible minimum, and expose behaviour with a reasonable amount of features. This helps to:</p>
<ul>
<li>hide implementation details</li>
<li>make maintenance easier for both, authors and users</li>
<li>reduce dependency of the user's software on your software</li>
<li>allow introducing changes faster.</li>
</ul>
<p>At this point we know what a package is, when to create one, and that it's important to design it carefully. A more practical advice on how to achieve most of these goals in code will be discussed further in this and following units. The primary focus of the remainder of this unit is the structure of a package. We start with a very special one, <code>main</code>, and then survey guidelines for regular packages.</p>
<h2 id="the-main-package"><a class="header" href="#the-main-package">The Main Package</a></h2>
<p>Keep the <code>main</code> package as small and focused as possible.</p>
<p>The <code>main</code> package defines the entry point of an application. This means that the code in this package is responsible for:</p>
<ul>
<li>obtaining the configuration required to set up the application from external sources</li>
<li>setting up the proper lifecycle (the topic is explained in detail in Module 2 - Foundation):
<ul>
<li>setting up proper error flow</li>
<li>making sure all allocated and occupied resources are <strong>always</strong> cleaned up and released</li>
<li>providing guarantees that all <code>defer</code>red calls are <strong>always</strong> executed</li>
<li>ensuring the service stops gracefully</li>
</ul>
</li>
<li>instantiating external dependencies for a service (this and other application-specific questions are considered in Module 3):
<ul>
<li>clients to any external services
<ul>
<li>databases and storages</li>
<li>other services</li>
</ul>
</li>
<li>any other connections without which the service cannot exist</li>
<li>any files required for the service to operate (incl. pid, lock, pipes)</li>
<li>the logger</li>
</ul>
</li>
<li>performing pre-flight checks</li>
<li>creating an instance of the service</li>
<li>starting up the service.</li>
</ul>
<p>The <code>main</code> package (and, as you'll know in a moment, the <code>main.go</code> file) is the <em>right</em> place to instantiate, create, check anything that is required for a service or application to start up and run correctly. Think about this the following way: anything that your app can't fix at runtime, <strong>must</strong> originate from the <code>main</code> package (and, as you'll know later, passed as arguments to the constructors of parts which the app is made of). As a consequence, <em>anything else should live outside of the <code>main</code> package</em>.</p>
<p>Here are some examples of what <em>can</em> originate from the <code>main</code> function:</p>
<ul>
<li>instances of any databases a service is using, unless the service can function fully without them, or the service is designed such that it can self-heal</li>
<li>any permissions in the system/platform under which the service is running, unless the service can fix or legally workaround missing entitlements</li>
<li>any files and related permissions that are relied upon at later stages, such as unix sockets, log files, temporary locations, configuration files, storages for data, and so forth</li>
<li>anything else without which it does not make sense to continue execution of the process, because there is no reason to allocate memory and waste resources if the environment you're running in and circumstance do not allow operating healthily. Unless, of course, you're expecting so and prepared for that.</li>
</ul>
<p>It's worth mentioning that there are some libraries that implicitly facilitate a poor layout of the <code>main</code> package. There are many applications out there available for looking at to obtain enough evidence to support this. When a project uses such a library, the recommendations from documentation are often taken as is, and the <code>main</code> package (and often the entire project) is deteriorated by the code which uses, is used or required by such libraries. So instead of simply copying code from the examples, think of a better way of organising code, so that the <code>main</code> package remains the entry point with as less contents as possible.</p>
<p>The contents of the <code>main</code> package, ideally, should be in the single file, <code>main.go</code>. The most important part of the <code>main.go</code> file is the <code>main</code> function. The package, file and function must be free from clutter, short and focused.</p>
<p>The suggestions above are not hard to follow when a service is well designed and thought through. The primary goal of these is to make the instantiation process clean and straightforward, as well as explicit. Another important goal is to reduce, as much as possible, the mental load required when working on a project. The <code>main.go</code> file is the introduction to the story you tell in code. So make sure the reader is welcomed to follow it, and not confused.</p>
<h2 id="package-provides-something"><a class="header" href="#package-provides-something">Package Provides Something</a></h2>
<p>A package <strong>provides</strong> tools for solving a particular problem.</p>
<p>It's important to understand that a package in Go is not a container for arbitrary code that shares some commonalities. It's not a container in the usual meaning of the word. Instead, a package is a <strong>provider</strong> of a way for accomplishing a set of tasks.</p>
<p>Think about how a library makes its way in to a project. There is a task to solve in the first place, and it is natural to seek for an existing solution first. Assuming a successful search, at the end of the process you find a library that does what you need, or significantly simplifies the task. So the library gives, or provides, something that you can use directly or as a building block. Notice that what you're searching for is not particular contents; it's rather a way, a solution, a tool to address a particular need. This illustrates that libraries (and not only in Go) for us, users, are providers, not collections.</p>
<p>That insight suggests what the author of a library should be focusing on. As an author, you design a package to provide the users of the package with ways for accomplishing a particular, <em>well-defined</em> set of tasks.</p>
<p>Yet the vast majority of packages seen in private codebases is still just collections of something. It's very common and sad to see packages that contain things, either literally, or by design. That's usually due to lack of understanding of the purpose of a package, combined with lack of design. Refrain from approaching problems in such a way.</p>
<p>The following example may sound corny, however it's worth repeating. A package named <code>tools</code> is a bad idea, the reasons given above tell us why. Such a package is a collection of usually arbitrary utility code that is either hard to decouple from its dependencies, or it has too wide, or sometimes too narrow, use case, so that it can't be put into a more specific and focused package. Thus, reject the idea of having a package like this. Instead, think about the following:</p>
<ul>
<li>how to make code less dependent on details so it can be moved into a focused package that <strong>provides</strong> something</li>
<li>or, keep the code where it's used
<ul>
<li>because it's unlikely to be needed somewhere else</li>
<li>or because more often than not <a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">duplication is cheaper than a wrong abstraction</a>.</li>
</ul>
</li>
</ul>
<p>If the reason for creating the <code>tools</code> package is to share code between other packages, ask the following questions:</p>
<ul>
<li>why can't I import the package that contains code that I want to use? The answer may suggest that there's a bigger and deeper problem with the design that prevents you from using it, thus it should be solved first. For example, dependencies pointing into a wrong direction might signal violation of The Dependency Inversion Principle (DIP).</li>
<li>shouldn't the code, that is going to be shared, belong in the type it operates on, as a method? Then both places, the method, and the caller, would use code naturally, without a separate package.</li>
<li>is there another way to address the issue?</li>
</ul>
<p>On the other side, the <code>model</code> package makes a lot of sense, as long as it provides the models that represent the data structures and components of a business process. Each model encapsulates its behaviour, and the consuming packages (those that operate on models) can describe a business process using the behaviour of a model.</p>
<p>Be sure the package you're about to create will provide something. That something comes in handy for the next step in planning a package.</p>
<h2 id="naming-a-package"><a class="header" href="#naming-a-package">Naming a Package</a></h2>
<p>The name of a package is one of its most important attributes. It impacts any place where it's mentioned, as well as code in the package. A good package name helps write expressive and understandable software.</p>
<p>Name packages consciously. The process requires thinking and planning. When packages are named well, the code using them is read naturally, and understanding of what it does is much easier. However, even a single poorly-named package in a project can significantly reduce readability, especially if it's an often-used one. The importance of a good name is so high because code is read more often than it's written. That's why you want to get it right.</p>
<p>This section goes into detail on choosing a good name for a package.</p>
<h3 id="context-and-namespace"><a class="header" href="#context-and-namespace">Context and Namespace</a></h3>
<p>The name of a package sets the context for its contents, and is the namespace. The package's context defines its meaning, role and responsibility.</p>
<p>When choosing a name for a package, make sure the name sets the right context, and is a good namespace. It's not a mere label, but a rather significant contributor to overall design, coherence, and readability of a project, no matter whether the project uses the package, or it <em>is</em> the package.</p>
<p>Consider <code>net/http</code>. Its context is everything that has to do with the HTTP protocol. It provides everything that we need to either talk to a server on the net, or to serve requests from clients. From the context, it's clear that there are things like requests, responses, headers, and so forth.</p>
<p>But it's also a namespace, because the name of a package, unlike in some languages, is used as part of an expression or statement. For example, the <code>Request</code> type. When you see <code>http.Request</code> it's clear that this type <strong>is</strong> an HTTP request, not an arbitrary request.</p>
<p>The context of a package is important for both, its authors and users.</p>
<p>As the author, you're already in the package which means there is absolutely no reason to duplicate information that can be derived from the context and namespace set by the name.</p>
<p>It would have been a non-sense to write <code>http.HTTPRequest</code>, <code>http.HTTPResponse</code>, or <code>bytes.BufferBytes</code>. Nonetheless, way too many developers in the Go community  still and often do so.</p>
<p>If you think that that's only applicable to the standard library, here is another, a real-life example. Compare the two:</p>
<ul>
<li><code>repository.UserRepository</code></li>
<li>and <code>repository.User</code>.</li>
</ul>
<p>The first is absurdly verbose and repetitive; the second is clear, concise and sufficient. The first is legacy coming from languages like Java or PHP, and alludes a poor design, and ignoring Go conventions, or not understanding them. The second is more idiomatic and Go-fashioned. Another example is <code>handler.AuthHandler</code> (too verbose, noisy) and <code>handler.Auth</code> (much better).</p>
<p>For a user, the name of a package is part of code, of every call and expression in which the package is used. Thus, a good name helps in making code easier to write, but most importantly â€“ read and understand. If the author of a package has put a good thought into the name, it improves the way code is perceived. Otherwise, each interaction with code would take more effort than it should; if you work with such code repeatedly and constantly, you'll soon realise how much more mental energy it takes, and how harder it is to maintain it.</p>
<p>A bad name leads to poorly-named objects, such as types, functions, methods, etc, which leads to a poor package API, which in turn leads to poor code that uses the package. Such code is legacy from the first symbol. This is how the code you write impacts others' codebases. And similarly, this is how your codebase is impacted by someone else's code.</p>
<p>Because of this, take the time and think it through before submitting, as an author, or accepting, as a user or reviewer, code with a new package. Think about your future self, and those who will use the package and maintain it, and code based on it. Only when the name and the contents of a package are balanced and play well together, merge or approve the pull request. Merged code is legacy, and you want it to be good.</p>
<h3 id="what-a-name-is-made-of"><a class="header" href="#what-a-name-is-made-of">What a Name is Made Of</a></h3>
<p>Before introducing guidelines on naming a package, it's important to understand what does create a name, technically.</p>
<p>Two things do contribute to the name of a package. The first thing is the name of the directory where it's located. The second is the <code>package</code> statement, the first non-comment line of any <code>.go</code> file in Go. Needless to remind that the directory name can contain hyphens, whereas the value in the <code>package</code> statement cannot.</p>
<p>The value specified by the <code>package</code> statement <strong>is</strong> the package name. The directory containing a package can be named arbitrary and unrelated to the package name, though it does not mean it's a good idea. Not all of what's possible is worth doing.</p>
<p>While this opens up an infinite number of choices for naming, it's better to stick to the conventions in the community.</p>
<h3 id="name-the-directory-after-the-package-it-contains"><a class="header" href="#name-the-directory-after-the-package-it-contains">Name the Directory After the Package it Contains</a></h3>
<p>Use the same name for the directory containing a package, and for the package itself.</p>
<p>If your package is named <code>rpc</code>, then the directory in which it's located <strong>must</strong> be named <code>rpc</code>.</p>
<p>So many projects and libraries violate this simple guideline. Don't confuse your future self, your colleagues and users, and use consistent naming between packages and directories.</p>
<h3 id="choose-short-and-concise-noun"><a class="header" href="#choose-short-and-concise-noun">Choose Short and Concise Noun</a></h3>
<p>The name of a package must be a <strong>singular, short, concise and expressive</strong> noun or an acronym, made of lower-case letters.</p>
<table><thead><tr><th align="left">Do</th><th align="left">Don't</th></tr></thead><tbody>
<tr><td align="left"><code>handler</code></td><td align="left"><code>handlers</code></td></tr>
<tr><td align="left"><code>storage</code></td><td align="left"><code>dataStorages</code></td></tr>
<tr><td align="left"><code>http</code></td><td align="left"><code>http_something</code></td></tr>
</tbody></table>
<p>This rule, as any other, has an exception. The name <em>can</em> be a plural noun <strong>if and only if</strong> it provides tools that work with things that can be described as a plural noun. Good examples are <code>bytes</code> and <code>strings</code>. They are named so not because they contain types that implement bytes and strings. It is because they provide tools for manipulating bytes and strings.</p>
<p>An example of the exception might be a hypothetical package <code>files</code> which provides tools for working with files in various ways. But even then, such a package might be questioned since its contents may belong in other packages. And the recent addition of the <code>io/fs</code> package proves it. The <code>fs</code> name stands for <code>filesystem</code>, and encapsulates a variety of tools for dealing with it.</p>
<p>So remember, a good package name is:</p>
<ul>
<li>singular</li>
<li>short</li>
<li>concise</li>
<li>precise.</li>
</ul>
<h3 id="avoid-common-tools-or-util"><a class="header" href="#avoid-common-tools-or-util">Avoid Common, Tools or Util</a></h3>
<p>Avoid common and vague names such as <code>common</code>, <code>tools</code>, <code>util</code> or similar.</p>
<p>This is may be one of the most often repeated mantras in Go, yet often a package like this is found in codebases.</p>
<p>Recently, even a previously considered as &quot;okay&quot; suffix <code>util</code> has become obsolete with the release of Go 1.16. The Go Team deprecated the <code>io/ioutil</code> package in favour of the <code>os</code> and <code>io</code> packages. So there is no more excuse even for your <code>dbutil</code> package, should you happen to have one, because why would it exist, if:</p>
<ul>
<li>it can be called <code>db</code></li>
<li>if <code>db</code> already exists, what does prevent you from adding code in it?</li>
</ul>
<h3 id="refrain-from-using-go-and-go--prefixes"><a class="header" href="#refrain-from-using-go-and-go--prefixes">Refrain From Using <code>go</code> and <code>go-</code> Prefixes</a></h3>
<p>Refrain from using the <code>go</code> and <code>go-</code> as prefixes or suffixes for a library, project, directory and the package name.</p>
<p>Does it sound controversial? Maybe. But why do we need to prefix anything with the name of the technology it's based on? This simply does not make sense.</p>
<p>The Go package and module system provide everything to guarantee uniqueness of names. It's also impossible to use a library named <code>somelib</code> written say in Java. So why would you need to name a Go implementation of anything as <code>go-somlib</code> or <code>gosomelib</code>? Find a better and unique name instead.</p>
<p>There are several issues with using <code>go</code> as a prefix/suffix:</p>
<ul>
<li>it adds zero useful information</li>
<li>if it contains a hyphen, then the library and package it contains have different names, which is confusing. The package inside a <code>go-somelib</code> library  is <code>somelib</code>, not <code>gosomelib</code> or <code>go-somelib</code>.</li>
</ul>
<p>If there is a strong need, desire or other reason to have <code>go</code> in the name, consider using it in the account/organisation name. The three most popular services for code collaboration and sharing (Github, Gitlab and Bitbucket), as well as self-hosted solutions (like Gitea and Gogs), use the account as a namespace for projects. Just compare:</p>
<table><thead><tr><th align="left">Do</th><th align="left">Don't</th></tr></thead><tbody>
<tr><td align="left"><code>github.com/golib/orion</code></td><td align="left"><code>github.com/someone/goorion</code></td></tr>
<tr><td align="left"><code>gitlab.com/go-lib/crux</code></td><td align="left"><code>gitlab.com/someone/go-crux</code></td></tr>
<tr><td align="left"><code>bitbucket.org/someone/lyra</code></td><td align="left"><code>bitbucket.org/gosomeone/golyra</code></td></tr>
</tbody></table>
<p>It's easy to see that the examples in the first column are shorter, cleaner, and nicer. This is what we want from names.</p>
<p>One exception needs to be made. It's easy to imagine a situation when an organisation has versions of the same library implemented in a number of distinct technologies. And Go might not be the first of them, and the most straightforward name might have already been taken. In such case, there are just a few options available:</p>
<ul>
<li>get creative, and use a different name. Many companies do so, and experience has shown this to be one of the best options. This guarantees uniqueness.</li>
<li>or, add a suffix to the repository name, but not to the module name. For example, Twitch has <code>twirp-ruby</code>  in addition to Go's <code>twirp</code>.</li>
</ul>
<table><thead><tr><th align="left">Good</th><th align="left">Acceptable</th></tr></thead><tbody>
<tr><td align="left"><code>github.com/myorg/thau</code></td><td align="left"><code>github.com/myorg/thau</code></td></tr>
<tr><td align="left"><code>github.com/myorg/theta</code></td><td align="left"><code>github.com/myorg/thau-go</code></td></tr>
<tr><td align="left"><code>github.com/myorg/omega</code></td><td align="left"><code>github.com/myorg/omega-cpp</code></td></tr>
</tbody></table>
<p>With this exception, it's still possible to:</p>
<ul>
<li>have a not so different name of a package/module/library</li>
<li>sort repositories by the name</li>
<li>unify naming across an organisation.</li>
</ul>
<p>Having figured out how to name a package, let's see how to better organise it.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>The next most important aspect of the package design is choosing and maintaining a healthy structure.</p>
<p>Similarly to the project layout, the package layout either improves the overall quality of the package, application and project, or unnecessary complicates, causes variety of issues, and just makes it harder to develop and support code.</p>
<p>It's important to structure packages well, as fixing it up at a later stage requires significantly more effort. Writing software is the easiest step in its lifecycle â€“ the better you do from the beginning, the lower the cost of its maintenance.</p>
<p>This section discusses the following guidelines:</p>
<ul>
<li>use flat structure by default</li>
<li>there are no sub-packages in Go.</li>
</ul>
<h3 id="flat-by-default"><a class="header" href="#flat-by-default">Flat by Default</a></h3>
<p>Most of the time, a package should have a flat structure, i.e. no structure at all.</p>
<p>That's it. As said earlier, do not introduce any structure for the sake of an artificial hierarchy. Several flat packages are better than some hierarchy when there is no actual need for that.</p>
<p>For example, when working on the <code>model</code> package, it does not make sense to have packages within it for each particular model.</p>
<table><thead><tr><th align="left">Do</th><th align="left">Don't</th></tr></thead><tbody>
<tr><td align="left"><code>model</code></td><td align="left"><code>model/user</code>, <code>model/track</code>, <code>model/playlist</code></td></tr>
</tbody></table>
<p>Here is what objects would look like for the first case:</p>
<ul>
<li><code>model.User</code></li>
<li><code>model.Track</code></li>
<li><code>model.Playlist</code></li>
<li>etc.</li>
</ul>
<p>Now compare it to an alternative, where everything is in a separate package. We would then get something more or less awful, for example:</p>
<ul>
<li><code>model/user.User</code></li>
<li><code>model/track.Track</code></li>
<li><code>model/playlist.Playlist</code></li>
<li>an so forth.</li>
</ul>
<p>However, there is a good reason for placing packages in a directory that has already got a package in it, â€“ the context provided by a good name.</p>
<h3 id="not-a-sub-package-but-a-package-in-the-same-directory"><a class="header" href="#not-a-sub-package-but-a-package-in-the-same-directory">Not a Sub-Package, But a Package in the Same Directory</a></h3>
<p>There is no such a thing as a sub-package in Go. Instead, when it makes sense and is appropriate, a package can be created in a directory that already has a package in it.</p>
<p>If there is no hierarchical relation between packages, then what would be a reason for such a placement? Like said earlier, a good name sets the proper namespace and context. Therefore, it would be great if it was possible to benefit from using these for other code which fits nicely nearby the package inside the directory.</p>
<p>One of the best examples is the <code>net</code> package. Have a look at which packages reside in the <code>net</code> <strong>directory</strong> alongside with the <code>net</code> package, in the standard library:</p>
<ul>
<li><code>http</code></li>
<li><code>mail</code></li>
<li><code>rpc</code></li>
<li><code>smtp</code></li>
<li><code>textproto</code></li>
<li><code>url</code>.</li>
</ul>
<p>While many developers are accustomed to think of them as <code>net/http</code>, <code>net/url</code> and so forth, the reality is that they're <code>http</code>, <code>url</code> and so on, respectively. What creates a feeling that the <code>http</code> package is a sub-package of <code>net</code>, is its import path. But that's only an import path. The package is <code>http</code>. And because the context and namespace set by <code>net</code> are appropriate and suitable for packages that deal with various aspects of networking, it makes a perfect sense to place them in that directory.</p>
<p>A real-life example of such placing would be a <code>handler/middleware</code> package. While <code>middleware</code> is a package on its own right, placing it under the <code>handler</code> <strong>directory</strong> is reasonable, because a middleware has to do with handling requests, and with handlers.</p>
<p>Use this sparingly and cautiously because of the risk of introducing a dependency cycle. The best way to avoid it is to have no shared code between packages at different levels. Design the relations such that dependencies always point into one, the same direction. For example, the package that is located at the parent directory can be imported by packages located deeper, but not the other way around. In some situations, it's reasonable to put all packages at the same level, by shifting what would be the top-level package into a child directory, so each package is in a sibling directory. Note that this is rather rare.</p>
<h2 id="files-in-a-package"><a class="header" href="#files-in-a-package">Files in a Package</a></h2>
<p>The Go package system is simple and powerful. It helps you prepare the foundation for the project; it is very convenient, and allows you to have short and concise names. There is no need to duplicate the information in the name of a package that is already being communicated by the path to the package and its location.</p>
<p>Up until now we've discussed mostly the ephemeral structure of a package - directories and naming. Code lives in files which a package is made of. How the files are named, how many of them, and how is the code split into files, are important and definitive aspects of the package design.</p>
<p>Since Go offers its own approach to packages, it's important to survey guidelines on how to put files in a package together. This section provides some advice on how to organise a package from the file perspective. And then the next unit further expands the topic.</p>
<p>Newcomers from other languages often don't know, nor do they learn the Go conventions, and use approaches that are unnatural and foreign to Go. Even those who envision themselves as seasoned Go developers, continue doing this unconsciously. It can be often found that a Go project looks much alike a PHP, Java, or C# one because the developer did not learn much about Go traditions and conventions. This leads to perpetuation of the problems that Go was created to solve.</p>
<p>Very few people learn the Go way of doing things, and even fewer do actually apply it in practice. You don't even need to open up a single file in a project to notice influence from other languages, and lack of good design. Countless files and poor naming are just a few examples of what could be improved.</p>
<p>A good design benefits from respecting and following Go-specific conventions. Some of the guidelines are:</p>
<ul>
<li>begin with a single file named after the package</li>
<li>keep type's declaration and all its methods in the same file</li>
<li>avoid creating file per object (type, function, etc)</li>
<li>prefer fewer files larger in size instead of numerous small files</li>
<li>when appropriate, move helpers in to a separate file</li>
<li>when appropriate, use a separate file for documentation.</li>
</ul>
<p>Let us look at each of the suggestions closer.</p>
<h3 id="begin-with-a-single-file-named-as-the-package"><a class="header" href="#begin-with-a-single-file-named-as-the-package">Begin With a Single File Named as the Package</a></h3>
<p>Begin with a single file that is named after the package.</p>
<p>In fact, this is two guidelines combined together:</p>
<ul>
<li>start with only one file</li>
<li>name that file as the package is named.</li>
</ul>
<p>A default tendency observed in many engineers is creating a taxonomy of files right at the beginning. Those files are named arbitrary, mostly poorly, due to behavioural patterns developed while working with other languages. This is unnecessary, and leads to a mess, not to mention it goes against the good traditions Go has established.</p>
<p>Instead, create just one file. Give it the same name as the package name. And then start adding some good code that you have thought about before writing.</p>
<p>As the package evolves, and new code is being added, it's reasonable to think about when it's the right time to add another file to the package. This leads to a deeper question â€“ when to split code into multiple files?</p>
<h3 id="organise-files-by-topic-responsibility-and-behaviour"><a class="header" href="#organise-files-by-topic-responsibility-and-behaviour">Organise Files by Topic, Responsibility and Behaviour</a></h3>
<p>Organise files by topic, responsibility and behaviour that are implemented in them. This is <strong>the</strong> criteria for splitting up a file into two.</p>
<p>A package is started with a single file, and everything resides in that file. At some point, a new piece of functionality is about to be added, but that piece, while relating to the main theme of the package, is slightly different from the rest of the contents of the file. What to do?</p>
<p>The answer depends on what is going to be added. If it's a type which one of the existing types will operate on, then it's better to keep them in the same file. It's also good to keep as many of similar objects in the same file as it makes sense. If you have multiple helper functions that are used as <code>http.HandlerFunc</code>, then it makes complete sense to keep them in the same file. Don't create a file per function only because it's a new function.</p>
<p>Sometimes though it's better to split functionality into two files. For instance, you're working on a library, and there are two core parts to it - a server, and a client. It's beneficial to keep them separately, as their responsibilities and roles are quite different. But everything that has to do with either the server or client, should belong in the same file as the other type.</p>
<h3 id="name-other-files-meaningfully"><a class="header" href="#name-other-files-meaningfully">Name Other Files Meaningfully</a></h3>
<p>When adding files later, name them after the most important type declared in the file, or after the primary responsibility of the contents of the file.</p>
<p>In Go, we name files after the most important thing in it. If it's hard to identify what's more important, then name it after the functionality it provides, or responsibility it carries.</p>
<p>In other languages, a file is usually named after the class in it. While it's alright in Go, and is used often, this is not the only contributor to the name of a file.</p>
<p>Make sure to use a <strong>single noun</strong>. Refrain from using plural nouns or other types of words.</p>
<h3 id="avoid-creating-file-per-object"><a class="header" href="#avoid-creating-file-per-object">Avoid Creating File per Object</a></h3>
<p>Avoid creating a file per object (type, function, etc).</p>
<p>Please don't. Go is not Java, PHP, C# or any other language where creating a file per class is either a must, or a poor tradition. Go is also not C/C++ where you used to have a header and implementation file (we will mention this further).</p>
<p>Instead, follow the guideline about the criteria for organising files above. Roles, responsibilities, behaviours â€“ these are the right factors indicating whether the contents needs to be split into files or not.</p>
<p>A file per type leads to the situations that have been considered in the previous sections and in the unit about project layout. Too many files complicate navigation, and increase cognitive load while working with a package, and so forth.</p>
<h3 id="prefer-fewer-files-of-larger-size"><a class="header" href="#prefer-fewer-files-of-larger-size">Prefer Fewer Files of Larger Size</a></h3>
<p>Prefer a fewer number of files of larger size instead of countless small files.</p>
<p>This is a natural consequence of the preceding advice. Fewer files is easier to navigate through. It does not produce clutter neither in the browser or terminal window, nor in the IDE. It's easier to organise and keep tidy.</p>
<h3 id="keep-methods-of-a-type-in-the-same-file"><a class="header" href="#keep-methods-of-a-type-in-the-same-file">Keep Methods of a Type in The Same File</a></h3>
<p>Keep the type's declaration and all its methods in the same file. Period.</p>
<p>One of the worst things one could do is split up the declaration of a type into multiple files. This is bad because of the increased effort required to maintain the mental map of a package, significantly reduced readability, and complicated understanding what the type does, its dependencies and responsibilities.</p>
<p>The two biggest problems with methods of a type scattered across multiple files are:</p>
<ul>
<li>understanding what the type is responsible for. You simply never know it until all files in the package are checked.</li>
<li>making changes to the type, especially changing an existing field of a method. Same problem as above, exacerbated by the fact that you have to check all the files in advance, as the change should be planned and thought about before you implement it. And, if implemented without the full picture, you may discover that the change does actually not make sense because of the way it's used on other place.</li>
</ul>
<p>So always keep everything that is part of the type declaration in the same file. Don't split the type declaration into several files. When a type is fully declared in a single place, it's easy to read and navigate through the code. The responsibilities and dependencies are easy to notice. It is also just easier to work with, literally.</p>
<p>As soon as you find such a type, the best thing that can be done is immediately gather the type declaration in the single file. It will save a lot of resources for present and not-so-far-future you, and everyone else working on the project.</p>
<p>There is one exception from this guideline, and we'll get back to it later. For now, it's sufficient to say that <strong>the only single reason</strong> for having some parts of a declaration in a separate file is implementing platform-dependent code. Otherwise, unless the exception is in effect, please don't.</p>
<h3 id="avoid-ambiguous-file-names"><a class="header" href="#avoid-ambiguous-file-names">Avoid Ambiguous File Names</a></h3>
<p>Avoid ambiguous names for files, such as <code>common</code>, <code>types</code>, etc.</p>
<p>The motivation is similar to the name of a package. Such names carry zero useful information about the contents. Our goal is to reduce energy required to understand what's happening in a package. Names like <code>common</code> complicate the task because it does not give any hint on what's in the file named as such.</p>
<p>The name <code>types</code> does not make sense as per the guidelines given above which recommend naming a file after the most important thing in it, and grouping contents by roles. It's impossible to have a file named <code>types</code> in a well-designed package. If you have one, you know what to do.</p>
<h3 id="use-a-separate-file-for-documentation-when-appropriate"><a class="header" href="#use-a-separate-file-for-documentation-when-appropriate">Use a Separate File for Documentation When Appropriate</a></h3>
<p>Use a separate file for documentation in a package which provides detailed explanations.</p>
<p>As you know, the top-level comment immediately preceding the <code>package</code> clause is the package comment. The first sentence <strong>is</strong> the package comment, and it can be optionally followed by a larger comment that is considered as a package-wide documentation.</p>
<p>Normally, the package comment must be written at the first file of a package. When you provide your users with detailed documentation, it would be good to keep it separate from the rest of code, but still within the package, so the Go documentation routines (<code>godoc</code>) are able to parse it.</p>
<p>There is a solution to this. Simply put the documentation along with the package comment in a file named <code>doc.go</code>. Normally and conventionally, the only content of this file is the package and documentation comments. Avoid adding anything else here.</p>
<pre><code class="language-golang">/*
Package mypackage provides a convenient way to do X. &lt;- the package comment

It achieves high performance by doing X using Y and Z.

Here is an example of using it.

Here is another one.

And here are some explanations about why is it valuable or any other useful information.
*/
package mypackage
</code></pre>
<p>Remember that this only makes sense for packages that have detailed documentation written in a specific way, i.e. the way <code>godoc</code> is able to understand. Otherwise, prefer more traditional places for documentation, such as  README files, documentation sites, etc.</p>
<p>Before we get to discussing how to organise a file internally in the lights of package design, there is one topic that is worth mentioning. The package layout is especially important when working on/with cross-platform software.</p>
<h2 id="cross-platform-code"><a class="header" href="#cross-platform-code">Cross-Platform Code</a></h2>
<p>The guidelines for designing packages would have been incomplete without considering writing software in which implementation details depend on the platform the software was created for. This brings us to the topic of cross-platform development in Go, from the package design perspective.</p>
<p>Writing, maintaining and deploying cross-platform code has never been as simple as it is with Go. It's not to say it's easy, but it has become much easier and simpler than it was before Go had come. The language provides us with built-in support for cross-compiling for multiple platforms so we don't even need to run the target system to build a binary for it. Tooling is excellent in this area, compared to other languages.</p>
<p>However, working on a cross-platform project is different from a single-platform one. All design and architectural decisions now are multiplied by the number of platforms you support. The need to properly test code and prove its correctness sets higher requirements for the design of services in the project.</p>
<p>Depending on the practices used to develop such a project, cross-platform experience might be as usual and smooth as single-platform, or it might turn into a nightmare. It is important to understand some basic principles of writing cross-platform code. The principles tell you what tools when to use. Careful planning, cautious and mindful approach to implementation are also necessary to avoid many pitfalls.</p>
<p>This section aims to aid you with advice on working with cross-platform code from the package organisation perspective. We will consider the following aspects of developing packages for multiple platforms:</p>
<ul>
<li>Basic Principles of Writing Cross-Platform Code</li>
<li>Cross-Platform Options in Go</li>
<li>Package and File Organisation.</li>
</ul>
<h2 id="basic-principles-of-writing-cross-platform-code"><a class="header" href="#basic-principles-of-writing-cross-platform-code">Basic Principles of Writing Cross-Platform Code</a></h2>
<p><em>Note: The content below is relevant to some other languages, though here we're mainly talking about Go. A reasonable amount of simplifications is in place. Pay attention, and <strong>think</strong> about what you read.</em></p>
<p>In one sentence, writing cross-platform code can be almost indifferent from writing for a single platform, <strong>if</strong> you've done the homework, i.e. have learned and followed good design and architecture principles and rules. The principles we're referring to are SOLID, some of the design patterns and common sense. Otherwise, if the good practices are neglected, chances for success are dramatically lower, or even zero.</p>
<p>As a general rule of thumb, all <strong>the business logic must be platform-agnostic</strong>. It is the implementation details what varies from platform to platform, but core algorithms remain common for all of them. This is important because even two platforms significantly increase the complexity just because all potential outcomes are now squared. Any design decision should be aligned with the main goal â€“Â reducing entropy in the software.</p>
<p>The starting point, and an obvious way to reduce entropy, is to <strong>keep the amount of cross-platform code at a possible minimum</strong>. The less code is different between platforms, the easier it is to guarantee its correctness, maintain and test it.</p>
<p>With the two principles applied, the likelihood of a project ending up in a better shape is higher. Though it's still possible that the project might not be able to achieve its goals due to specifics of one of the supported platforms. If it is the case, there are essentially two potential scenarios. One is trying to maintain all features on par for each platform. While this is the ideal and desired situation, it may often lead to waste of resources since not everything is equally possible across available platforms.</p>
<p>The other possible scenario is a reasonable and pragmatic trade off. What helps in staying efficient is to <strong>know when to mock missing cross-platform features or skip them at all</strong>. Not every system feature has something similar in another system.</p>
<p>For example, there is no direct alternative to Windows's Registry in Linux or FreeBSD. Of course, in Unix, Linux-based systems and its derivatives we have a kernel and the <code>sysctl</code> API or similar, but that's not exactly the same thing is the Registry (One may argue that <code>systemd</code> has been working hard to become a Linux counterpart of the Windows Registry). Trying to mimic its behaviour would be tedious and unjustifiably complex. In such case, two potential alternatives are available â€“ one is to abstract the business logic such that it does not depend on a particular system feature, and the other is to skip one system that does not support some functionality that is important in another system.</p>
<p>To get a sense of how implementation details can vary across many platforms, have a look at <a href="https://golang.org/pkg/net/#pkg-note-BUG">the list of differences in the <code>net</code> package</a> in the Go standard library.</p>
<h2 id="cross-platform-options-in-go"><a class="header" href="#cross-platform-options-in-go">Cross-Platform Options in Go</a></h2>
<p>One of the key strengths of the Go programming language is its powerful tooling focused on developer's productivity. Fast compilation and ease of dependency management are vital for the ecosystem. But tools for writing and building multi-platform code are what make Go truly special.</p>
<p>Writing and maintaining cross-platform software (without distribution) is a two-stage process:</p>
<ul>
<li>the code needs to be written in a way that allows changing its behaviour based on the platform it's running on</li>
<li>the code then needs to be compiled for each supported platform.</li>
</ul>
<p>We talk about the second stage first, and then dig deeper into the first.</p>
<h3 id="terminology"><a class="header" href="#terminology">Terminology</a></h3>
<p>Before we get too far in the discussion, it's good to agree on the terminology used in next sections.</p>
<p>In this work, as well as in the community, we use the following terms with the corresponding meanings:</p>
<ul>
<li>Go operating system, or simply operating system, as per the environment variable <code>GOOS</code> â€“ one of the target operating systems Go supports. Expressed as one of the predefined values.</li>
<li>Go architecture, or simply architecture, as per the environment variable <code>GOARCH</code> â€“ one of the the target system architectures Go supports. Similarly to the operating system, it's one of the predefined values.</li>
<li>Go platform, or just platform, a combination of the two, an operating system and architecture, in this order. This term is not used in code or as a setting, but is used in discussions and documentation. When you see a use of the term &quot;platform&quot; in a conversation that is related to cross-platform software in Go, it means a combination of an operating system and architecture. For instance, these sentences are written on the <code>darwin/amd64</code> platform.</li>
</ul>
<p>It's worth reminding that each of <code>GOOS</code> and <code>GOARCH</code> and, therefore, the platform, can, and usually is, defined implicitly by inferring the value from the environment, if not set explicitly. When you're running <code>go build</code> on your Intel-based Mac without setting the environment variables, <code>GOOS=darwin</code> and <code>GOARCH=amd64</code> are supplied to the compiler. In this case, the target platform is <code>darwin/amd64</code>. On a Raspberry Pi under Linux, it would be <code>linux/arm</code> and additional <code>GOARM</code>. Similar effect can be achieved on any other platform with variables explicitly set as follows <code>GOOS=linux GOARCH=arm GOARM=6</code>.</p>
<p>While we're on this topic, it's no harm in repeating that when only one of the variables specified to a value that is different from the current system value, the other is inferred from the current system. For the rest of the book, if not mentioned explicitly, the implied value of <code>GOARCH</code> is <code>amd64</code>.</p>
<p>Okay, now we can move forward. The next section is a quick refresher of the compilation process, and then we dive into creating packages that support several platforms.</p>
<h3 id="compiling-for-multiple-platforms"><a class="header" href="#compiling-for-multiple-platforms">Compiling For Multiple Platforms</a></h3>
<p>Even if a project has no code that depends on a platform, the binary format has to match the requirements and expectations of a target system. In Go, there are two options for compiling code for more than one platform:</p>
<ul>
<li>simply building on each of the target platforms</li>
<li>cross-compile for each of the supported platforms.</li>
</ul>
<p>With the first option, the code for each of the supported platforms is built on that platform. In its simplest form, the build process looks no different from what we do every day â€“ <code>go build</code> is <code>go build</code>, after all. What differs is the artefact which is specific to the platform it has been built on.</p>
<p>The second option offers a slightly different approach. The result is controlled by a pair of well-known environment variables that tell the compiler what it should produce. This process is also known as <strong>cross-compilation</strong>:</p>
<pre><code class="language-bash">GOOS=freebsd GOARCH=amd64 go build -o myapp-freebsd-amd64
GOOS=linux GOARCH=arm go build -o myapp-linux-arm
GOOS=windows GOARCH=386 go build -o myapp-windows-386.exe
GOOS=darwin GOARCH=amd64 go build -o myapp-darwin-amd64
</code></pre>
<p>Which of the two options when to use? It depends on your environment, priorities, available resources and limitations. The native compilation option is the easiest from the tooling perspective. You simply run the same set of tools to test and build code, and get the results. A major downside is the need to run and maintain instances of all platforms, which might be expensive as it requires some (potentially, significant) additional resources (i.e. costs you time, attention and money).</p>
<p>On the other hand, the second option is less demanding to the build infrastructure. All code is built on the developers's machine or in a single instance of CI/CD. Platform-agnostic code is tested on the most available platform, but running tests for platform-specific code still requires native instances.</p>
<p>So choose wisely. The guideline is to use cross-compilation for producing release artefacts, and to use specialised, automated test environment to run tests against platform-dependent code.</p>
<p>It's worth noting that, in its simplest form, a cross-platform program has no differences in the implementation between supported platforms (not counting potential differences in the standard library). In such case, all what is needed is compiling a binary for each platform. That's exactly what we've just covered.</p>
<p>Compiling code for multiple systems is a relatively easy step. But to build something, we have to write it first. The question is how to do it, and do it in a right way.</p>
<h3 id="developing-for-multiple-platforms"><a class="header" href="#developing-for-multiple-platforms">Developing for Multiple Platforms</a></h3>
<p>When working on functionality which involves special features of an operating system, a specialised implementation is required for the varying part. Then, different implementations need to be incorporated with the platform-independent business logic of the project.</p>
<p>Go offers <strong>build constraints</strong> to enable conditional compilation. This allows to write specialised code for a particular platform, and guarantees that the code is included and available only when compiled for that target system. For all other platforms, which are not covered by constraints, such code simply does not exist.</p>
<p>Build constraints can be expressed in two ways:</p>
<ul>
<li>using the file name</li>
<li>using build tags.</li>
</ul>
<p>When compiling, the two environment variables <code>GOOS</code> and <code>GOARCH</code> and/or the build flag <code>-tags</code> are used to control the process. Specifically, these settings tell the compiler when and what to include in the resulting binary.</p>
<p>As you will learn or remember soon, while the two ways under the hood work in the same way (due to the <code>go/build</code> package), in everyday development each of them has own pros and cons. They can be used independently in simple scenarios. More often though, they're used together as it allows more flexible behaviour, but sometimes it's just the only way to express the constraints. Let's briefly recap what each of them is, and then learn how to employ them to make the design of a package better.</p>
<p><em>NOTICE:</em> The contents below covers topics such as using build tags and file names for conditional compilation. The text has been written when Go 1.16 has been released. Everything below applies for Go versions <em>up to 1.16</em>. Starting from version <strong>1.17</strong>, things will change. There is <a href="https://go.googlesource.com/proposal/+/master/design/draft-gobuild.md">a proposal</a> which has been <a href="https://github.com/golang/go/issues/41184">accepted</a>. This is going to be quite a large language change, on par with introduction of Modules. I will keep this part of the unit updated as the new behaviour is available, and it's clear what happens to the existing approach. For now, we focus on the existing way of managing compilation.</p>
<h3 id="the-file-name"><a class="header" href="#the-file-name">The File Name</a></h3>
<p>We start with the method based on the file name suffix. If a source file has a suffix that is a valid operating system, architecture or a combination of the two, then the file is compiled only for that platform.</p>
<p>Here are some examples, for a package <code>mypkg</code>:</p>
<ul>
<li><code>mypkg_linux.go</code> is included in the binaries for Linux and any architecture (of course, for those that are supported by Go)</li>
<li><code>mypkg_amd64.go</code> is included in binaries for any operating system running on the <code>amd64</code> architecture (also known as <code>x86_64</code>, <code>Intel 64</code>, but these are not valid names in Go)</li>
<li><code>mypkg_windows_386.go</code> is included in the binary only when targeted at x86-based 32-bit Windows</li>
<li><code>mypkg_posix.go</code> is included on any platform (remember, <code>platform = os + arch</code>, hence on any os and any arch) as <code>posix</code> is not a valid operating system nor architecture identifier for the Go toolchain.</li>
</ul>
<p><em>When</em> to include a file is controlled by the environment at the build time:</p>
<ul>
<li>when running <code>go build</code> the values are derived from the system the build is running on, i.e. your machine or the machine the command is executed on</li>
<li>or when <code>GOOS</code> and/or <code>GOARCH</code> are explicitly set.</li>
</ul>
<p>This also works with testing. To write a platform-specific test you simply add the familiar <code>test</code> suffix to the end of the corresponding file name or to any file that will include such code:</p>
<ul>
<li><code>mypkg_linux_test.go</code> is included only when running <code>go test</code> on Linux, or <code>GOOS=linux go test</code> on any system</li>
<li><code>mypkg_amd64_test.go</code> is included only when running <code>go test</code> on an x86-based 64-bit system, or <code>GOARCH=amd64 go test</code> on any other architecture</li>
<li><code>mypkg_windows_386_test.go</code> is included only when running <code>go test</code> on an x86-based 32-bit Windows, or <code>GOOS=windows GOARCH=386 go test</code> on any system</li>
<li>and so on.</li>
</ul>
<p>For all available GOOS and GOARCH valid values and combinations please visit <a href="https://golang.org/doc/install/source#environment">this page</a>.</p>
<p>As you see, the approach offers an easy way for separating code for a particular system. It's enough in simple cases or when code is different between all the systems your project works on. But what if a more fine grained control is needed? Or what if code is the same for Windows and Linux, but is different for macOS?</p>
<p>Another use case is including/excluding code at the compilation time based not only on a platform, or even not on the platform at all, but on a custom criterion. For example, you may want to include some features in the free version of your product, and other features only in the binary shipped to the paying users. You may even have multiple paid tiers with three sets of features, and the corresponding binaries should include all features from the preceding tiers plus something else. Or you may even want to offer different implementations of the same feature based on the tier?</p>
<p>The answer to these and many other questions about conditional compilation is build tags.</p>
<h3 id="build-tags"><a class="header" href="#build-tags">Build Tags</a></h3>
<p>Build constraints in Go are expressed in a form of build tags. As you may already know, a build tag is a line comment that begins with <code>// +build</code> and lists the conditions under which a file should be included when compiling and/or testing the project.</p>
<h4 id="basics"><a class="header" href="#basics">Basics</a></h4>
<p>The following rules are in effect when using build constraints:</p>
<ul>
<li>multiple tags may be listed on the same line</li>
<li>multiple lines with build tags may appear, one next to another</li>
<li>tags may appear in any kind of source file (not limited to Go)</li>
<li>constraints must appear close to the top of the file</li>
<li>they may be preceded only by blank lines and other comments</li>
<li>a series of build tag lines must be followed by an empty line (to distinguish from the documentation)</li>
<li>all this means that in Go files, build constraints must appear only <strong>before</strong> the <code>package</code> clause.</li>
</ul>
<p>There are also certain rules for writing and grouping build tags:</p>
<ul>
<li>when listed on the same line, space-separated tags are interpreted as <code>OR</code></li>
<li>if an option contains a comma, then it's evaluated as <code>AND</code> of its separated terms</li>
<li>allowed symbols for a term are letters, digits, underscores and dots</li>
<li>a term can be negated when preceded with an exclamation mark <code>!</code></li>
<li>when constraints are expressed as multiple lines, the overall result is the <code>AND</code> of individual lines</li>
<li>a special tag of <code>// +build ignore</code> can be used to exclude the file from consideration.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li>a simple build constraint</li>
</ul>
<pre><code class="language-golang">// +build linux,arm windows,386
</code></pre>
<p>It results to the following: <code>(linux AND arm) OR (windows AND 386)</code>.</p>
<ul>
<li>multiple build tags</li>
</ul>
<pre><code class="language-golang">// +build linux darwing
// +build amd64
</code></pre>
<p>It results to the following: <code>(linux OR darwin) AND (amd64)</code></p>
<ul>
<li>with negation</li>
</ul>
<pre><code class="language-golang">// +build linux darwin,!cgo
</code></pre>
<p>Which results to <code>(linux) OR (darwin AND NOT cgo)</code>.</p>
<h4 id="more-control"><a class="header" href="#more-control">More Control</a></h4>
<p>The use of build tags is not limited to only platforms. Other conditions can be expressed in the very same way, for even more advanced control over the compilation. In the example below, we want to offer three tiers in the service â€“ free, silver and gold. Each subsequent tier should include the features from the preceding tier. This is how it can be achieved on the compilation level which may help protect your app against cracking and/or bypassing licensing terms:</p>
<ul>
<li>define a base line, with no tags, in <code>base.go</code></li>
<li>define a the first paid tier, or <code>silver</code> level, in <code>silver.go</code></li>
</ul>
<pre><code class="language-golang">// +build silver
</code></pre>
<ul>
<li>define a the second paid tier, <code>gold</code>, in <code>gold.go</code></li>
</ul>
<pre><code class="language-golang">// +build silver
// +build gold
</code></pre>
<p>Notice that we have to list the both tags, <code>silver</code> and <code>gold</code> for the second tier, as we want it to include the features from the preceding tier. That's because of the way how the boolean logic is expressed using the constraints.</p>
<h4 id="passing-tags"><a class="header" href="#passing-tags">Passing Tags</a></h4>
<p>Now, how to tell compiler about constraints?</p>
<p>Build constraints are inferred from three places, two of which you already know:</p>
<ul>
<li>some environment variables, such as <code>GOOS</code>, <code>GOARCH</code>, <code>CGO_ENABLED</code>, etc</li>
<li>the suffix of the name of a Go source file</li>
<li>when explicitly passed as a special build flag of comma separated values when running <code>build</code>, <code>test</code> and other commands, as <code>-tag tag1,tag2,tag3</code>.</li>
</ul>
<p>Note that the file name's suffix method is mentioned here. That's because, as said earlier, under the hood it works as a build constraint. When a file has a suffix that matches a valid supported operating system, architecture, or a combination of the two, the file is considered to have an implicit build constraint set to the values in the suffix.</p>
<h4 id="using-only-build-tags"><a class="header" href="#using-only-build-tags">Using Only Build Tags</a></h4>
<p>Having reminded ourselves what a build tag is, let's continue exploring options for cross-platform development.</p>
<p>As mentioned earlier, conditions for platform-dependent compilation can be expressed using file name suffixes. In a basic scenario, when the implementation details are different for, say, <code>windows</code> and <code>linux</code>, it's easy to express with <code>mypkg_windows.go</code> and <code>mypkg_linux.go</code>, in addition to <code>mypkg.go</code>.</p>
<p>However, what to do when two different platforms have the exact same implementations? One way is to simply have two separate files with same contents. For example, <code>app_darwin.go</code> and <code>app_freebsd.go</code>. But this kind of duplication is not something we normally want, unless we have to.</p>
<p>A much better approach is to use build tags for expressing conditions for the compilation process. It helps in making things cleaner and removes the need of duplicating the code. Add a build tag to the file, and give it a meaningful name that does not conflict with the supported operating systems, say <code>app_unix.go</code>:</p>
<pre><code class="language-golang">// +build darwin freebsd
</code></pre>
<p>Now whenever the code is built on each of the mentioned platforms, or with the help of the environment variable <code>GOOS</code>, code will be included in binaries for either of the operating systems.</p>
<h3 id="using-suffixes-and-tags"><a class="header" href="#using-suffixes-and-tags">Using Suffixes and Tags</a></h3>
<p>Finally, let's consider another possible situation where a feature's implementation is different for some platforms, but is the same for others. The suffix-based method can be used in combination with build tags.</p>
<p>To illustrate this situation, let's assume the low-level implementation is different for Windows on the one hand, and Linux with macOS on the other, though the latter is the same for Linux and macOS. Then a reasonable approach would be to put the Windows-specific code into <code>myapp_windows.go</code> file, and let the suffix control inclusion of this code. For Linux and macOS, put implementation into <code>myapp_posix.go</code> and add the following build constraint at the top of the file:</p>
<pre><code class="language-golang">// +build linux darwin
</code></pre>
<p>And that's it. The environment variables and/or build flags passed to <code>go build</code> or <code>go test</code> are now in control of what's included during the process.</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<p>As you see, Go offers convenient tools for writing, building and shipping cross-platform software. Those who wrote programs for more than one platform in the past agree that Go has made huge progress in making the process easier. Those who haven't got cross-platform experience yet would probably not be surprised, if the first experience happened to be with Go. But then they would definitely notice the difference if faced cross-platform development with other languages.</p>
<p>These tools are great, but that's not enough on its own to produce great software and developer experience in short and long term. To achieve a good level of efficiency we need something else, and that's what the next section is about â€“ actual advice on cross-platform packages.</p>
<h2 id="package-and-file-organisation"><a class="header" href="#package-and-file-organisation">Package and File Organisation</a></h2>
<p>By now, we have learned a few foundational principles and tools that guide and help us when working on a piece of cross-platform software. Next step is to look at how to combine and apply them to make software maintainable and the process of maintenance as smooth as possible. The ultimate goal is to make code simple and easy to work with; we also strive to simplify support of such software.</p>
<p>The section introduces practical advice on how to design packages and files better in a cross-platform project. This includes:</p>
<ul>
<li><a href="u02-13-cp-keep-code-at-minimum.html#keep-platform-dependent-code-at-minimum">Keep Platform-Dependent Code at Minimum</a></li>
<li><a href="u02-14-cp-simple-branching.html#use-simple-branching-in-trivial-cases">Use Simple Branching in Trivial Cases</a></li>
<li><a href="u02-15-cp-no-platform-code-in-main.html#no-platform-specific-code-in-main">No Platform-Specific Code in Main</a></li>
<li><a href="u02-16-cp-file-suffix-by-default.html#use-file-suffix-by-default">Use File Suffix by Default</a></li>
<li><a href="u02-17-cp-build-tags-in-mixed-cases.html#use-build-tags-in-mixed-cases">Use Build Tags in Mixed Cases</a></li>
<li><a href="u02-18-cp-advanced-example.html#an-advanced-example">An Advanced Example</a></li>
<li><a href="u02-19-cp-platform-independent-tests.html#strive-for-platform-independent-tests">Strive for Platform-Independent Tests</a></li>
<li><a href="u02-20-cp-cross-platform-tests.html#provide-cross-platform-tests-only-when-you-must">Provide Cross-Platform Tests Only When You Must</a>.</li>
</ul>
<p>Let's talk about each of them in more detail. And we begin with repeating one of the basic principles.</p>
<h3 id="keep-platform-dependent-code-at-minimum"><a class="header" href="#keep-platform-dependent-code-at-minimum">Keep Platform-Dependent Code at Minimum</a></h3>
<p>Keep the amount of platform-specific code at a possible minimum.</p>
<p>Sounding very simple, it's one of the hardest to follow, and the most often ignored piece of advice. By its nature, it goes hand-in-hand with the common sense in package design â€“ keep the public API of a package as narrow as possible.</p>
<p>The best way to keep things simple is to have no cross-platform code. But often that's not possible, and some code has to be made platform-dependent. In such case, you have to keep the amount of such code as small as possible.</p>
<p>Having learned the tools for conditional compilation, you know that it's possible to conditionally include code in the final binary depending on the constraints specified at the build time. This leads to a question about what code to pull into files that are conditionally included? Or, in a more general form, what parts of the code are better to be made cross-platform?</p>
<p>Looking at the problem from a general software design perspective, our building blocks in code are:</p>
<ul>
<li>types</li>
<li>methods</li>
<li>and helper functions.</li>
</ul>
<p>Therefore, when working in a cross-platform context, these are what can have varying implementations between platforms supported by a project. However, the guideline says that it's good to keep the code at a minimum. This helps in deriving guiding principles for writing cross-platform code.</p>
<p>In general, when working with varying implementations for the same functionality for several platforms, bear in mind the following suggestions:</p>
<ul>
<li>in the worst case, types are implemented differently for each platform, but obey the same interface/contract</li>
<li>a slightly better option is to allow methods vary between platforms</li>
<li>the best option is to pull platform specifics into helper functions.</li>
</ul>
<p>The insightful reader might have already noticed that these guidelines do support and reflect two of the basic principles introduced at the beginning of this unit, namely:</p>
<ul>
<li>the business logic must be platform-agnostic</li>
<li>and keep the amount of cross-platform code at a possible minimum.</li>
</ul>
<p>The first of the two is supported by the fact that by default you aim to pull platform-specifics in to helpers. This guarantees that methods and types do not depend on a platform, thus less business logic is leaking to the platform.</p>
<p>The second is supported by the fact that aiming for having no details leaked to type and method levels, a lower amount of platform-dependent code is automatically guaranteed.</p>
<p>One warning should be made though. The guideline does not prevent you from introducing platform-specific <strong>helper types</strong> when it helps to improve the logic of software and its design. What should be avoided, however, is platform-specific public API of a package. If a public method or type depends on a platform, then decouple the public part and use cross-platform private implementations that are not exposed to the user. This drastically improves both, the user and developer experience. Being free to change the implementation without the risk of breaking user's applications is vital for productive and efficient maintenance of any software, but even more so in the cross-platform world.</p>
<h3 id="use-simple-branching-in-trivial-cases"><a class="header" href="#use-simple-branching-in-trivial-cases">Use Simple Branching in Trivial Cases</a></h3>
<p>Use simple branching in trivial cases.</p>
<p>A simplest form of cross-platform code is setting a variable within an <code>if</code> or <code>switch</code> statement depending on values of <code>runtime.GOOS</code>, <code>runtime.GOARCH</code> or <code>runtime.Version()</code>.</p>
<p>Such code does not require any build constraints (reminder, build constraints can be expressed as a suffix in the name of a file, or as a build tag). The result depends on the values of the corresponding constants or the returned value of the <code>Version()</code> function, which in turn depend on the system where the program is running and/or version of Go used during the build process.</p>
<p>However, it's tempting to abuse this method. Beware that it is only helpful in very basic cases like choosing the appropriate extension of a file name or something similar. Never implement different <strong>behaviour</strong> based on branching depending on the aforementioned values. This leads to fragile architecture and complicates testing, debugging and maintenance overall.</p>
<p>This method helps to choose what path the execution will follow <strong>at runtime</strong>, but it <em>does not imply</em> conditional compilation. If implementations vary between platforms, and are not available on them at the same time, then builds will be broken.</p>
<p>Essentially, one of the most reasonable uses of this option is to determine and/or report what actual platform the code is <em>running</em> on.</p>
<p>Don't confuse runtime conditions with compile-time conditions.</p>
<h3 id="no-platform-specific-code-in-main"><a class="header" href="#no-platform-specific-code-in-main">No Platform-Specific Code in Main</a></h3>
<p>Keep the <code>main</code> function, as well as the <code>main</code> package, free from platform-dependant code.</p>
<p>This guideline is a natural and logical consequence of the fact that the <code>main</code> package must contain the smallest possible amount of code. When initialisation steps are encapsulated in a separate single or multiple packages, it's possible to have platform-specific initialisation wherever it is required. Other advantages of this are improved testability and separation of concerns.</p>
<p>Technically, the rules that manage conditional compilation apply to the <code>main</code> package and the files in it, as to any other package. However, if your <code>main</code> contains platform-specific code, it suggests there is <em>likely</em> a problem with design and architecture â€“Â implementation details have leaked at the highest level of the application hierarchy. The <code>main</code> package must be as free as possible from any details.</p>
<h3 id="use-file-suffix-by-default"><a class="header" href="#use-file-suffix-by-default">Use File Suffix by Default</a></h3>
<p>Use the file suffix to manage cross-platform code by default, i.e. when the conditions for compilation are simple.</p>
<p>What this suggestion means is that in simple cases where the platforms you need to support are discrete and don't share commonalities, the simplest possible way is to use suffixes with files containing code for a particular platform, be it different operating systems, architectures, or a combination of the two criteria.</p>
<p>For instance, suppose you have a CLI application that must support Linux and Windows, and the architecture does not matter (as in <code>amd64</code> or <code>386</code>), and something requires a different implementation for each of the platforms. In this case, we have a simplest condition possible â€“Â two different operating systems. The best way to express it is to use suffixes:</p>
<pre><code class="language-bash">â””â”€â”€ something
    â”œâ”€â”€ something.go
    â”œâ”€â”€ something_linux.go
    â””â”€â”€ something_windows.go
</code></pre>
<p>Nothing else is required. Not even a single tag. Then, as discussed earlier, there are two ways to build it:</p>
<ul>
<li>on the same machine, using cross compilation:</li>
</ul>
<pre><code class="language-bash"># For Linux.
GOOS=linux go build -o bin/myapp-linux ./cmd/myapp

# For Windows.
GOOS=windows go build -o bin/myapp-windows.exe ./cmd/myapp
</code></pre>
<ul>
<li>on machines with the corresponding platforms the environment variable is not needed:</li>
</ul>
<pre><code class="language-bash"># On Linux.
go build -o bin/myapp-linux ./cmd/myapp

# On Windows.
go build -o bin/myapp-windows.exe ./cmd/myapp
</code></pre>
<h3 id="use-build-tags-in-mixed-cases"><a class="header" href="#use-build-tags-in-mixed-cases">Use Build Tags in Mixed Cases</a></h3>
<p>Use build tags and suffixes in mixed cases, i.e. when some platforms have their unique implementations, but some share code.</p>
<p>Let's extend the previous example by the following requirement: the app should also support macOS, <code>darwin</code> in Go's vocabulary, and the implementation of the platform-specific part is exactly the same as it is for Linux. This is a pretty common situation for macOS. Some parts work close or similar to the <code>linux</code> platform, some are similar to those in <code>freebsd</code>, while some are unique to <code>darwin</code> itself.</p>
<p>In the case of our example, we have two options:</p>
<ul>
<li>implement the new requirement separately for <code>darwin</code>, hence in its own file, <code>something_darwin.go</code></li>
<li>or re-use the existing implementation which, for the sake of exercise, is assumed to be the same.</li>
</ul>
<p>The former option has a rather weak advantage of not bothering with conditional compilation, and just relies on the automatic choice the compiler makes. A big disadvantage though is unjustified duplication, which clearly can and should be avoided. And this is exactly what the second option is about.</p>
<p>In order to re-use the existing implementation for <code>darwin</code>, and continue supporting <code>linux</code>, we need to make a few changes:</p>
<ul>
<li>first off, stop relying on the file suffix, as there is no file suffix that would include both <code>linux</code> and <code>darwin</code>, and exclude all other platforms at the same time. This means, we shall rename the file</li>
<li>secondly, we need to specify a proper build tag to tell the compiler when it should include the file.</li>
</ul>
<p>How to choose a new name for the <code>something_linux.go</code> file? We can't simply append <code>_darwin</code> at the end, as this file becomes suffixed with <code>darwin</code>, and will be only included for this platform. The name should not be a valid word from the list of operating systems, platforms and any other words supported by Go. Here are a few examples:</p>
<ul>
<li><code>something_darlin.go</code></li>
<li><code>something_lindar.go</code></li>
<li><code>something_linuxdarwin.go</code>.</li>
</ul>
<p>However, this particular case is very often. What's common between Linux, macOS, and many other Unix and Unix-like operating systems? Right, they are, though to varying degrees, compliant with POSIX. So a pretty common thing to see in the standard library and other cross-platform projects is the use of the word <code>posix</code> as a suffix for cases when Linux and other operating systems from the Unix family share same code. Going further, you can also often run into cases when you have something common among all or many Unices, but different for Linux. In such case, for example, code that is the same for FreeBSD, OpenBSD, NetBSD and macOS can be put into a file with a name suffixed by <code>_unix.go</code>. Keep this in mind, and don't reinvent the wheel.</p>
<p>Alright, the name problem is solved. The existing file needs to be renamed from <code>something_linux.go</code> to <code>something_posix.go</code>. The name does not tell anymore the compiler when to include and exclude the file, but a tag will do. The code in the file should be built for Linux or macOS. That <code>or</code> is really important, as it's a condition. It does not make sense to express it as <code>and</code>, since this is an impossible combination (an operating system cannot be Linux and macOS at the same time). Here is what the resulting tag should look like:</p>
<pre><code class="language-golang">// +build linux darwin
</code></pre>
<p>Also, keep in mind the rules about the placement of a build tag.</p>
<p>This is what our example was like before the changes:</p>
<ul>
<li>directory listing:</li>
</ul>
<pre><code class="language-bash">.
â”œâ”€â”€ bin
â”œâ”€â”€ cmd
â”‚Â Â  â””â”€â”€ myapp
â”‚Â Â      â””â”€â”€ main.go
â””â”€â”€ something
    â”œâ”€â”€ something.go
    â”œâ”€â”€ something_linux.go
    â””â”€â”€ something_windows.go
</code></pre>
<ul>
<li>and the content of the <code>something_linux.go</code> file:</li>
</ul>
<pre><code class="language-golang">package something

const (
	Feature2 = &quot;this is a version supported by a number of unix-like systems&quot;
)
</code></pre>
<p>This is what it looks like after the changes:</p>
<ul>
<li>directory listing:</li>
</ul>
<pre><code class="language-bash">.
â”œâ”€â”€ bin
â”œâ”€â”€ cmd
â”‚Â Â  â””â”€â”€ myapp
â”‚Â Â      â””â”€â”€ main.go
â””â”€â”€ something
    â”œâ”€â”€ something.go
    â”œâ”€â”€ something_posix.go
    â””â”€â”€ something_windows.go
</code></pre>
<ul>
<li>and the content of the <code>something_posix.go</code> file:</li>
</ul>
<pre><code class="language-golang">// +build linux darwin

package something

const (
	Feature2 = &quot;this is a version supported by a number of unix-like systems&quot;
)
</code></pre>
<ul>
<li>building:</li>
</ul>
<pre><code class="language-bash"># On/For Mac.
$ GOOS=darwin go build -o bin/myapp-darwin ./cmd/myapp

# Running.
$ ./bin/myapp-darwin
common feature for all platforms
this is a version supported by a number of unix-like systems
</code></pre>
<h3 id="an-advanced-example"><a class="header" href="#an-advanced-example">An Advanced Example</a></h3>
<p>Here is another question: What if we need to support a third feature which is unique to the Mac, and is unavailable for all other platforms? In this case, we should use the full power available at our disposal, and also avoid exposing the difference to <code>main</code>. How can this be accomplished?</p>
<p>We can use our example to illustrate the approach. Let's assume there should be a feature that does something on <code>darwin</code> but does not exist/has no effect on other platforms. There are two approaches available:</p>
<ul>
<li>mock the behaviour on the platforms that don't have the feature, so it can be called in a platform-independent way, i.e. make it no-op</li>
<li>or encapsulate the platform-dependent call such that it's not exposed to the platform-independent code, hence is transparent.</li>
</ul>
<p>The latter is available and really helpful in real life when implementing unique parts nested within a higher-level code that is called by code that is unaware of different platforms. For our example we'll follow the former way, but the second is preferred whenever it's possible.</p>
<p>Also note, that a simple <code>if runtime.GOOS == &quot;darwin&quot; { // unique code }</code> won't do the trick. Why? Because it will be attempted to be included for all platforms during compilation, and conditioned only at runtime.</p>
<p>Let's introduce a third feature which should work only on the Mac, while all existing conditions must remain. In order to make this happen, we:</p>
<ul>
<li>implement the new feature for <code>darwin</code></li>
<li>mock it for <code>windows</code> and <code>linix</code></li>
<li>the second step implies that we have to add a Linux-specific file. We'll use the suffix for that.</li>
</ul>
<p>We also don't want to make a special case for the existing code shared between Linux and macOS. The fact that we're now going to support all three platforms, does not mean we should have a separate platform-specific implementation, just for the sake of separation. As one of the guiding principles says, the more code can be shared and/or abstracted, the better. And if the second feature introduced earlier remains the same for the two platforms, there is absolutely no point in splitting it.</p>
<p>Let's have a look at the project after the necessary have been made.</p>
<ul>
<li>directory listing:</li>
</ul>
<pre><code class="language-bash">.
â”œâ”€â”€ bin
â”œâ”€â”€ cmd
â”‚Â Â  â””â”€â”€ myapp
â”‚Â Â      â””â”€â”€ main.go
â””â”€â”€ something
    â”œâ”€â”€ something.go
    â”œâ”€â”€ something_darwin.go
    â”œâ”€â”€ something_linux.go
    â”œâ”€â”€ something_posix.go
    â””â”€â”€ something_windows.go
</code></pre>
<p>Notice the two new files, <code>something_darwin.go</code> and <code>something_linux.go</code>.</p>
<ul>
<li>the <code>main.go</code> file:</li>
</ul>
<pre><code class="language-golang">package main

import (
	&quot;fmt&quot;

	&quot;../../something&quot;
)

func main() {
	fmt.Println(something.Feature1)
	fmt.Println(something.Feature2)

	something.DoFeature3()
}
</code></pre>
<p>Notice how the code does not depend on platform here.</p>
<ul>
<li><code>something.go</code></li>
</ul>
<pre><code class="language-golang">package something

const (
	Feature1 = &quot;common feature for all platforms&quot;
)
</code></pre>
<p>This piece of code is common among all supported platforms.</p>
<ul>
<li><code>something_darwin.go</code></li>
</ul>
<pre><code class="language-golang">package something

import (
	&quot;fmt&quot;
)

func DoFeature3() {
	fmt.Println(&quot;this is a unique feature for the mac&quot;)
}
</code></pre>
<p>This code is compiled for and executed only when running on the Mac.</p>
<ul>
<li><code>something_linux.go</code></li>
</ul>
<pre><code class="language-golang">package something

func DoFeature3() {}
</code></pre>
<p>Here we mock the missing functionality for Linux.</p>
<ul>
<li><code>something_posix.go</code></li>
</ul>
<pre><code class="language-golang">// +build linux darwin

package something

const (
	Feature2 = &quot;this is a version supported by a number of unix-like systems&quot;
)
</code></pre>
<p>This code remains the same, as it works nicely for the two platforms, hence no change is needed. This file is included for both platforms.</p>
<ul>
<li><code>something_windows.go</code></li>
</ul>
<pre><code class="language-golang">package something

const (
	Feature2 = &quot;this is a windows specific version&quot;
)

func DoFeature3() {}
</code></pre>
<p>Finally, for Windows, the new feature is mocked in this existing file.</p>
<p>Here are a few results of building and running:</p>
<pre><code class="language-bash"># Build for darwin.
GOOS=darwin go build -o bin/myapp-darwin ./cmd/myapp

# Run on darwin.
$ ./bin/myapp-darwin
common feature for all platforms
this is a version supported by a number of unix-like systems
this is a unique feature for the mac


# Build for linux.
$ GOOS=linux go build -o bin/myapp-linux ./cmd/myapp

# Run on linux.
$ docker run -it --rm -v $(pwd)/bin:/root/bin/ alpine:3.13 ash
% /root/bin/myapp-linux
common feature for all platforms
this is a version supported by a number of unix-like systems
</code></pre>
<p>As you see, the feature works as expected on macOS, and is non-existent on Linux. <em>Quod Erat Demonstrandum.</em></p>
<h3 id="strive-for-platform-independent-tests"><a class="header" href="#strive-for-platform-independent-tests">Strive for Platform-Independent Tests</a></h3>
<p>Write platform-independent tests whenever possible.</p>
<p>This suggestion is corollary to and supports the previous two guidelines. Maintenance of multi-platform code is not a trivial business, and has its cost. By making sure that the code is designed to be as much as possible independent of the platform it's run on, and only really low-level parts do differ, we have hopefully reduced the cost. But the code has to be tested, and since tests are also code, the same rules apply.</p>
<p>Platform-independent approach to tests works best in a case where the result of an operation or behaviour must be the same across all platforms despite different low-level implementation details. In such a case, the low-level code does not necessarily need to be covered, as long as tests are run against all target platforms.</p>
<p>To illustrate this, let's slightly update our example. We'll add a feature that has to work uniformly across all platforms, but will have three different implementations. Let's say we need to add a fourth feature which prints <code>&quot;this feature has different implementations but yields the same result&quot;</code> on all three supported operating systems (here, as in <code>GOOS</code>).</p>
<p>This is what the code looks like:</p>
<ul>
<li>this is our platform-independent high-level code, <code>something.go</code>:</li>
</ul>
<pre><code class="language-golang">package something

import (
	&quot;fmt&quot;
)

const (
	Feature1 = &quot;common feature for all platforms&quot;
)

func RunFeature4() {
	fmt.Println(Feature4())
}

func Feature4() string {
	return doFeature4()
}
</code></pre>
<p>Notice the <code>RunFeature4</code> function which internally calls the <code>doFeature4</code> function. Where is it declared? It's not declared in any file that is visible for all platforms simultaneously. Instead, each of the platforms has its own implementation. Here we go:</p>
<ul>
<li>for <code>darwin</code>, <code>something_darwin.go</code>:</li>
</ul>
<pre><code class="language-golang">package something

import (
	&quot;fmt&quot;
)

var (
	feature4 = []byte(`this feature has different implementations but yields the same result`)
)

func DoFeature3() {
	fmt.Println(&quot;this is a unique feature for the mac&quot;)
}

func doFeature4() string {
	return string(feature4)
}
</code></pre>
<p>Here, the special implementation of <code>doFeature4</code> uses the slice of <code>byte</code>s as the source.</p>
<ul>
<li>for <code>linux</code>, <code>something_linux.go</code>:</li>
</ul>
<pre><code class="language-golang">package something

func DoFeature3() {}

func doFeature4() string {
	return &quot;this feature has different implementations but yields the same result&quot;
}
</code></pre>
<p>In the world of Linux, things are often more straightforward. We just return a <code>string</code>.</p>
<ul>
<li>here is <code>windows</code>, <code>something_windows.go</code>:</li>
</ul>
<pre><code class="language-golang">package something

const (
	Feature2 = &quot;this is a windows specific version&quot;
)

var (
	feature4 = []rune(`this feature has different implementations but yields the same result`)
)

func DoFeature3() {}

func doFeature4() string {
	return string(feature4)
}
</code></pre>
<p>In Windows, our implementation is based on a slice of <code>rune</code>s.</p>
<ul>
<li>finally, this is how the feature is used, <code>main.go</code>:</li>
</ul>
<pre><code class="language-golang">package main

import (
	&quot;fmt&quot;

	&quot;../../something&quot;
)

func main() {
	fmt.Println(something.Feature1)
	fmt.Println(something.Feature2)

	something.DoFeature3()
	something.RunFeature4()
}
</code></pre>
<ul>
<li>building and running:</li>
</ul>
<pre><code class="language-bash"># Darwin.
$ GOOS=darwin go build -o bin/myapp-darwin ./cmd/myapp
$ ./bin/myapp-darwin
common feature for all platforms
this is a version supported by a number of unix-like systems
this is a unique feature for the mac
this feature has different implementations but yields the same result

# Linux.
$ GOOS=linux go build -o bin/myapp-linux ./cmd/myapp
$ docker run -it --rm -v $(pwd)/bin:/root/bin/ alpine:3.13 ash
% /root/bin/myapp-linux
common feature for all platforms
this is a version supported by a number of unix-like systems
this feature has different implementations but yields the same result
</code></pre>
<p>The output suggests that the feature works as expected. But how can we prove it remains working over time, especially given that changes to software are made often, not to mention that platforms do not stand still too, and are being constantly updated? Of course, with tests. In this case, the outcome is and must be exactly the same for all platforms. So this outcome <strong>is the result</strong> we want to make sure is always correct, not the implementation detail. If something happens to the implementation, then the broken test will highlight it.</p>
<p>In cases like this, <strong>write platform-independent</strong> tests.</p>
<p>To illustrate this situation, here are two example tests:</p>
<ul>
<li>the first checks the feature itself</li>
<li>the second tests how it works end-to-end.</li>
</ul>
<p>Here is the <code>something_test.go</code> file, which is in effect on all platforms:</p>
<pre><code class="language-golang">package something_test

import (
	&quot;bufio&quot;
	&quot;os&quot;
	&quot;strings&quot;
	&quot;testing&quot;

	&quot;../something&quot;
)

func TestFeature4(t *testing.T) {
	exp := &quot;this feature has different implementations but yields the same result&quot;
	act := something.Feature4()

	if act != exp {
		t.Errorf(&quot;expected: %s, got: %s\n&quot;, exp, act)
	}
}

func TestRunFeature4(t *testing.T) {
	stdout := os.Stdout
	r, w, err := os.Pipe()
	if err != nil {
		t.Errorf(&quot;failed to create reader and writer: %s\n&quot;, err)
		t.FailNow()
	}

	os.Stdout = w
	something.RunFeature4()

	b := bufio.NewReader(r)
	out, err := b.ReadString('\n')
	if err != nil {
		t.Errorf(&quot;failed to read from reader: %s\n&quot;, err)
		t.FailNow()
	}

	if err := w.Close(); err != nil {
		t.Errorf(&quot;failed to close writer: %s\n&quot;, err)
		t.FailNow()
	}

	os.Stdout = stdout

	exp := &quot;this feature has different implementations but yields the same result&quot;
	if act := strings.TrimSuffix(out, &quot;\n&quot;); act != exp {
		t.Errorf(&quot;expected: %q, got: %q\n&quot;, exp, act)
	}
}
</code></pre>
<p>Notice how neither of the two tests has any knowledge about the platform-specific code. In the first test, <code>TestFeature4</code>, we check that the feature is implemented correctly. The second test, <code>TestRunFeature4</code>, does a full check, including capturing the result from the standard output.</p>
<p>Here are test results:</p>
<ul>
<li>on macOS:</li>
</ul>
<pre><code class="language-bash">$ go test ./something/... -v
=== RUN   TestFeature4
--- PASS: TestFeature4 (0.00s)
=== RUN   TestRunFeature4
--- PASS: TestRunFeature4 (0.00s)
PASS
ok  	_/Users/user/projects/xplatform/something	0.005s
</code></pre>
<ul>
<li>and on Linux, using the <code>golang:1.15</code> image:</li>
</ul>
<pre><code class="language-bash">$ docker run -it --rm -v $(pwd):/root/xplatform golang:1.15 bash
% cd /root/xplatform/
% go test ./something/... -v
=== RUN   TestFeature4
--- PASS: TestFeature4 (0.00s)
=== RUN   TestRunFeature4
--- PASS: TestRunFeature4 (0.00s)
PASS
ok  	_/root/xplatform/something 0.003s
</code></pre>
<p>The output is exactly the same, and tests pass in both cases. And that's what we should strive for.</p>
<h3 id="provide-cross-platform-tests-only-when-you-must"><a class="header" href="#provide-cross-platform-tests-only-when-you-must">Provide Cross-Platform Tests Only When You Must</a></h3>
<p>Provide platform-specific tests only when you must.</p>
<p>If we had lived in a perfect world, platform-agnostic tests would have been enough. Since this is not the case, under some circumstances we have to provide our code with specialised tests. There are two main reasons for having specialised tests:</p>
<ul>
<li>the feature being tested is not available on all platforms, hence there is no way to test it uniformly in accordance with the previous guideline</li>
<li>or the platform-specific implementation detail is crucial, and requires an extra cautious approach.</li>
</ul>
<p>Note that the latter of the two reasons is rather rare for most cases of casual and business software. A good illustration of this and the preceding guidelines can be found in the <code>net</code> package of the Go's standard library. The vast majority of the package's tests operates on platform-independent code, and only a few parts are provided with specialised tests.</p>
<p>When a single or a group of platforms needs a separate set of tests, follow the same rules as with regular cross-platform code:</p>
<ul>
<li>in simple cases, use file name suffixes, e.g. <code>something_darwin_test.go</code></li>
<li>in cases where a number of platforms share the same implementation and tests, use a meaningful suffix and build tags, e.g. <code>something_unix_test.go</code> and <code>// +build darwin freebsd</code>.</li>
</ul>
<p>To give an example, let's add a test to the feature that is unique for the <code>darwin</code> platform in the demo code shown previously. As a reminder, this is the platform-specific implementation we're going to test, <code>something/something_darwin.go</code>:</p>
<pre><code class="language-golang">package something

import (
	&quot;fmt&quot;
)

var (
	feature4 = []byte(`this feature has different implementations but yields the same result`)
)

func DoFeature3() {
	fmt.Println(&quot;this is a unique feature for the mac&quot;)
}

func doFeature4() string {
	return string(feature4)
}
</code></pre>
<p>In particular, we're interested in the <code>DoFeature3</code> function, as it's available only on the Mac; on all other platforms it's mocked as <code>func DoFeature3() {}</code>. The implementations are different, so there is no way it can be expressed in a clean way. Of course, one can always write <code>if runtime.GOOS() == &quot;darwin&quot; { ... }</code>, but that's rather naÃ¯ve. Why would we allow such a leak of details to a higher level of abstraction?</p>
<p>Instead, we create a file to hold the tests for the platform of interest, <code>something_darwin_test.go</code> in our case, and fill it with test code:</p>
<pre><code class="language-golang">package something_test

import (
	&quot;bufio&quot;
	&quot;os&quot;
	&quot;strings&quot;
	&quot;testing&quot;

	&quot;../something&quot;
)

func TestDoFeature3(t *testing.T) {
	stdout := os.Stdout
	r, w, err := os.Pipe()
	if err != nil {
		t.Errorf(&quot;failed to create reader and writer: %s\n&quot;, err)
		t.FailNow()
	}

	os.Stdout = w
	something.DoFeature3()

	b := bufio.NewReader(r)
	out, err := b.ReadString('\n')
	if err != nil {
		t.Errorf(&quot;failed to read from reader: %s\n&quot;, err)
		t.FailNow()
	}

	if err := w.Close(); err != nil {
		t.Errorf(&quot;failed to close writer: %s\n&quot;, err)
		t.FailNow()
	}

	os.Stdout = stdout

	exp := &quot;this is a unique feature for the mac&quot;
	if act := strings.TrimSuffix(out, &quot;\n&quot;); act != exp {
		t.Errorf(&quot;expected: %q, got: %q\n&quot;, exp, act)
	}
}
</code></pre>
<p>Running the tests emits the following output:</p>
<ul>
<li>on macOS</li>
</ul>
<pre><code class="language-bash">$ GOOS=darwin go test ./something/... -v
=== RUN   TestDoFeature3
--- PASS: TestDoFeature3 (0.00s)
=== RUN   TestFeature4
--- PASS: TestFeature4 (0.00s)
=== RUN   TestRunFeature4
--- PASS: TestRunFeature4 (0.00s)
PASS
ok  	_/Users/user/projects/xplatform/something	0.006s
</code></pre>
<ul>
<li>and on Linux, the output is still the same as before</li>
</ul>
<pre><code class="language-bash">$ docker run -it --rm -v $(pwd):/root/xplatform golang:1.15 bash
% cd /root/xplatform/
% go test ./something/... -v
=== RUN   TestFeature4
--- PASS: TestFeature4 (0.00s)
=== RUN   TestRunFeature4
--- PASS: TestRunFeature4 (0.00s)
PASS
ok  	_/root/xplatform/something 0.003s
</code></pre>
<p>Organising cross-platform code and tests this way allows for:</p>
<ul>
<li>better encapsulation of responsibilities</li>
<li>better isolation of changes</li>
<li>more clarity on what, when, where and how</li>
<li>and this all results into a healthier software and process.</li>
</ul>
<p>This example shows a couple of important things â€“Â that it is possible to have specialised tests if needed, and that the complexity and cost of maintenance grow much faster with each new varying detail. While being able to test the specifics of a platform is important, it's also important to use this ability wisely. The best code is unwritten code; but a better code is the one that checks for the outcome rather than for a specific implementation detail. This supports the guideline â€“ write platform-specific tests only when you must, and try to cover as much as possible at the platform-independent level. It will save you time and energy.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>This unit went one layer deeper in the project structure, and discussed guidelines for package design. Its leitmotif is similar to the one of the project layout â€“Â mindful, thoughtful and responsible choices do a better job short and long-term, for your peers and you.</p>
<p>Here is a quick recap of the suggestions in this unit:</p>
<ol>
<li>Create a package to improve the design of software, not for the sake of having a package.</li>
<li>The <code>main</code> package is special, and must be kept as minimal as possible.</li>
<li>When creating a new package, make sure to:
<ul>
<li>keep the public API as narrow as possible</li>
<li>provide a solution for a task</li>
<li>choose a good and meaningful name which
<ul>
<li>sets the right context and namespace</li>
<li>is consistent with the environment, and is not confusing</li>
<li>is short and concise singular noun</li>
<li>is precise and focused, i.e. avoid <code>common</code>, <code>util</code>, <code>tools</code>, etc</li>
<li>and is unique.</li>
</ul>
</li>
</ul>
</li>
<li>Organise a package properly, in accordance with Go conventions:
<ul>
<li>prefer a flat list of packages by default</li>
<li>there is no such thing as a sub-package in Go, organisationally speaking.</li>
</ul>
</li>
<li>Keep files in a package in a good order:
<ul>
<li>begin with a single file named as the package</li>
<li>organise files by topic, responsibility and behaviour</li>
<li>name other files meaningfully</li>
<li>avoid creating file per object</li>
<li>prefer fewer files of larger size</li>
<li>keep methods of a type in the same file</li>
<li>avoid ambiguous file names</li>
<li>use a separate file for documentation when appropriate.</li>
</ul>
</li>
<li>To minimise or reduce the maintenance burden when working with cross-platform code:
<ul>
<li>follow the basic principles of writing cross-platform code
<ul>
<li>the business logic must be platform-agnostic</li>
<li>the amount of cross-platform is as minimal as possible</li>
<li>significant differences between platforms are compensated by minimal mocking or no-op implementations</li>
</ul>
</li>
<li>know the tools available for cross-platform development in Go
<ul>
<li>ways to produce binaries</li>
<li>approaches to differentiating code between supported platforms
<ul>
<li>using file names</li>
<li>or build tags</li>
<li>and how to combine them when needed</li>
</ul>
</li>
</ul>
</li>
<li>organise packages containing cross-platform code with change in mind, i.e.:
<ul>
<li>keep platform-dependent code at minimum</li>
<li>use simple branching in trivial cases</li>
<li>have no platform-specific code in <code>main</code></li>
<li>use file suffix in simple cases</li>
<li>use build tags when more flexibility is needed</li>
<li>strive for platform-independent tests</li>
<li>and provide cross-platform tests only when you must.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>These guidelines are the continuation of the project level recommendations at a higher resolution. Applied together and in a consistent manner, this sets up a solid foundation for a codebase. Even if you inherited a disorganised codebase, it would be possible to improve its structure by taking small steps towards the better shape. As long as you keep improving it, and continue making right design choices, the codebase eventually reaches, or remains in, a good shape. And then you have to continue, as nothing is static, and is always evolving.</p>
<p>The next step will take us one more layer further â€“Â the level of a file in a package. We've made the necessary preparations, and are ready for discussing code organisation within a file.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
